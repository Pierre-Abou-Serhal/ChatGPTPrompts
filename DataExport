using System.Data;
using System.Net;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using ExcelDataReader;

// Entry Point
Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);

const String filePath = @"D:\Test.xlsx";

ValidateFileRes res = ReadExcelFile(File.ReadAllBytes(filePath));

Console.WriteLine(JsonSerializer.Serialize(res.ParsedDataList));

return;

// Logic
static ValidateFileRes ReadExcelFile(Byte[] fileBytes)
{
    String correlationId = Guid.NewGuid().ToString();
    
    ValidateFileReq req = new()
    {
        CorrelationId = correlationId,
        FileInfo = new()
        {
            ValidateHeader = false,
            Encoding = EncodingEnum.UTF8,
            Delimiter = "",
            FileBinary = BitConverter.ToString(fileBytes).Replace("-", ""),
            FileType = FileType.EXCEL,
            HeaderRowNumber = 1,
            ValidateHeaderContainsFields = [],
            SkipRowStrings = [new SkipRowString {SkipString = "Georges", IsRegExp = false}],
            Columns = [
                new()
                {
                    ColumnNumber = 1,
                    FindFromHeader = false,
                    HeaderColumnName = "",
                    StartRowNumber = 2,
                    ReadEndCondition = ReadEndCondition.FILE_END,
                    ReadEndConditionValue = "",
                    CustomDataValidation = [
                        new (){InjestFilePropertyId = 1}
                    ]
                },
                new()
                {
                    ColumnNumber = 3,
                    FindFromHeader = false,
                    HeaderColumnName = "",
                    StartRowNumber = 2,
                    ReadEndCondition = ReadEndCondition.FILE_END,
                    ReadEndConditionValue = "",
                    CustomDataValidation = [
                        new (){InjestFilePropertyId = 1}
                    ]
                }
            ]
        }
    };
    
    ValidateFileRes res = new()
    {
        WebResp = new()
        {
            CorrelationId = correlationId
        }
    };
    
    using MemoryStream excelMemoryStream = new (fileBytes);
    
    using IExcelDataReader? reader = ExcelReaderFactory.CreateReader(excelMemoryStream);
    DataSet? result = reader.AsDataSet(new ExcelDataSetConfiguration
    {
        ConfigureDataTable = (_) => new ExcelDataTableConfiguration
        {
            UseHeaderRow = false // Read raw data first
        }
    });

    DataTable table = result.Tables[0]; // First Sheet

    // Parsed Data List that will be returned to client
    List<ParsedData> parsedDataList = [];
    List<String> headerList = [];
    
    foreach (Column column in req.FileInfo.Columns)
    {
        List<Int32> injestFilePropertyIds = [];
        List<String> columnData = [];

        ParsedData parsedData = new()
        {
            ColumnIndex = column.ColumnNumber
        };

        // Read End Condition Variables
        Int32 whiteLineCount = 0;

        foreach (DataRow row in table.Rows)
        {
            Int32 rowNumber = table.Rows.IndexOf(row) + 1; // IndexOf(row) is zero based
            
            // Checking if End Condition is reached
            List<String> rowValues = row.ItemArray.Select(cell => cell?.ToString()?.Trim() ?? String.Empty).ToList();

            if (IsReadEndConditionReached(
                    column.ReadEndCondition,
                    rowValues,
                    whiteLineCount,
                    rowNumber, 
                    column.ReadEndConditionValue))
            {
                return res;
            }

            // Extracting Header Data
            if (req.FileInfo.ValidateHeader &&
                rowNumber == req.FileInfo.HeaderRowNumber)
            {
                foreach (String cell in rowValues)
                {
                    if (cell.Equals(column.HeaderColumnName))
                    {
                        parsedData.ColumnName = column.HeaderColumnName; // Header Name Was Found
                    }

                    headerList.Add(cell);
                }

                // Check if header contains the values in "ValidateHeaderContainsFields" array
                ExtractionBLL_CheckHeaderEvent(headerList,
                    req.FileInfo.ValidateHeaderContainsFields, ref res);

                // Header did not pass checking event
                if (res.WebResp.Errors.Count > 0)
                {
                    throw new SGBLBadRequestException("Invalid Header Fields");
                }
            }

            // Extracting Row Data
            if (rowNumber < column.StartRowNumber)
            {
                continue;
            }

            // Checking if a value in a row match any skip string value
            Boolean skipRow = false;

            foreach (SkipRowString skipRowString in req.FileInfo.SkipRowStrings)
            {
                foreach (String cell in rowValues)
                {
                    if (skipRowString.IsRegExp)
                    {
                        if (Regex.IsMatch(cell, skipRowString.SkipString))
                        {
                            skipRow = true;
                            break;
                        }
                    }
                    else
                    {
                        if (cell.Contains(skipRowString.SkipString))
                        {
                            skipRow = true;
                            break;
                        }
                    }
                }
            }

            if (skipRow)
            {
                continue;
            }

            String cellValue = column.FindFromHeader
                ? row[column.HeaderColumnName].ToString() ?? String.Empty
                : row[column.ColumnNumber == 0 ? column.ColumnNumber : column.ColumnNumber - 1 ].ToString() ?? String.Empty;

            injestFilePropertyIds =
                column.CustomDataValidation.Select(i => i.InjestFilePropertyId).ToList();

            if (!String.IsNullOrWhiteSpace(cellValue))
            {
                columnData.Add(cellValue);
            }

            if (rowValues.All(String.IsNullOrWhiteSpace))
            {
                whiteLineCount++;
            }
        }

        //OnCheckRowsDataEvent?.Invoke(injestFilePropertyIds, columnData, ref res);

        if (res.WebResp.Errors.Count > 0)
        {
            throw new SGBLBadRequestException($"Invalid Column {column.ColumnNumber} Fields");
        }

        parsedData.Data = columnData;
        parsedDataList.Add(parsedData);
    }

    res.ParsedDataList = parsedDataList;

    return res;
}

static Boolean IsReadEndConditionReached(
    ReadEndCondition condition,
    List<String> row,
    Int32 whiteLineCount,
    Int32 rowNumber,
    String conditionValue)
{
    Boolean isReached = false;

    Int32.TryParse(conditionValue, out Int32 conditionValueInt);

    switch (condition)
    {
        case ReadEndCondition.WHITE_LINE_COUNT:
            isReached = whiteLineCount >= conditionValueInt;
            break;

        case ReadEndCondition.FILE_END:
            isReached = false;
            break;

        case ReadEndCondition.ROW_NUMBER:
            isReached = rowNumber >= conditionValueInt;
            break;

        case ReadEndCondition.ROW_CONTAINS:
            isReached = row.Contains(conditionValue);
            break;
    }

    return isReached;
}

static void ExtractionBLL_CheckHeaderEvent(List<String> headerList, List<String> mustContainList, ref ValidateFileRes result)
{
    foreach (String headerName in mustContainList)
    {
        if (!headerList.Contains(headerName))
        {
            result.WebResp.Errors.Add($"Header Name: {headerName} Is Missing From The Header");
        }
    }
}

#region Models
 public class FileInfo
    {
        public String FileBinary { get; set; } = String.Empty;
        public FileType FileType { get; set; }
        public String Delimiter { get; set; } = String.Empty;
        public EncodingEnum Encoding { get; set; }
        public Boolean ValidateHeader { get; set; }
        public Int32 HeaderRowNumber { get; set; }
        public List<String> ValidateHeaderContainsFields { get; set; } = [];
        public List<SkipRowString> SkipRowStrings { get; set; } = [];
        public List<Column> Columns { get; set; } = [];
    }
    
    public class SkipRowString
    {
        public String SkipString { get; set; } = String.Empty;
        public Boolean IsRegExp { get; set; }
    }

    public class Column
    {
        public Boolean FindFromHeader { get; set; }
        public String HeaderColumnName { get; set; } = String.Empty;
        public Int32 ColumnNumber { get; set; }
        public Int32 StartRowNumber { get; set; }
        public ReadEndCondition ReadEndCondition { get; set; }
        public String ReadEndConditionValue { get; set; } = String.Empty;
        public List<CustomDataValidation> CustomDataValidation { get; set; } = [];
    }
    
    public class CustomDataValidation
    {
        public Int32 InjestFilePropertyId { get; set; }
    }

    public class FileValidationStep
    {
        public Int32 InjestFilePropertyId { get; set; }
        public String ApplicationOwner { get; set; } = String.Empty;
        public String ValidationWorkflowName { get; set; } = String.Empty;
        public String InjestFileDescription { get; set; } = String.Empty;
        public Int32 ValidationStepId { get; set; }
        public String ValidationStepName { get; set; } = String.Empty;
        public Boolean ContinueIfFail { get; set; }
        public Int32 ChunkSize { get; set; }
        public Int32 ProcedureId { get; set; }
        public String ProcedureName { get; set; } = String.Empty;
        public String ProcedureDescription { get; set; } = String.Empty;
        public Boolean IsTVP { get; set; }
        public String InputName { get; set; } = String.Empty;
        public String TVPMap { get; set; } = String.Empty;
    }

    public class InjestFileProperty
    {
        public Int32 Id { get; set; }
        public String ApplicationOwner { get; set; } = String.Empty;
        public String ValidationWorkflowName { get; set; } = String.Empty;
        public String Description { get; set; } = String.Empty;
    }

    public class ParsedData
    {
        public Int32 ColumnIndex { get; set; }
        public String ColumnName { get; set; } = String.Empty;
        public List<String> Data { get; set; } = [];
    }
#endregion

#region Enums
public enum FileType
{
    EXCEL = 1,
    CSV = 2,
}

public enum ReadEndCondition
{
    FILE_END = 1,
    WHITE_LINE_COUNT = 2,
    ROW_NUMBER = 3,
    ROW_CONTAINS = 4
}

public enum EncodingEnum
{
    UTF8 = 1,
    LATIN1 = 2,
    UNICODE = 3,
    BIGENDIANUNICODE = 4,
    UTF32 = 5,
    ASCII = 6,
    WINDOWS1256 = 7
}

public static class EncodingEnumExtensions
{
    public static Encoding GetEncoding(this EncodingEnum encodingEnum)
    {
        switch (encodingEnum)
        {
            case EncodingEnum.UTF8:
                return Encoding.UTF8;
            
            case EncodingEnum.LATIN1:
                return Encoding.Latin1;
            
            case EncodingEnum.UNICODE:
                return Encoding.Unicode;
            
            case EncodingEnum.BIGENDIANUNICODE:
                return Encoding.BigEndianUnicode;
            
            case EncodingEnum.UTF32:
                return Encoding.UTF32;
            
            case EncodingEnum.ASCII:
                return Encoding.ASCII;
            
            case EncodingEnum.WINDOWS1256:
                Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);
                return Encoding.GetEncoding(1256);
            
            default:
                return Encoding.Default;
        }
    }
}

public enum DataIntegrityCheckFunctions
{
    IS_INVALID_CORRELATION_ID = 0,
    IS_INVALID_FILE_TYPE = 1,
    IS_INVALID_ENCODING = 2,
    IS_INVALID_DELIMITER = 3,
    IS_INVALID_COLUMNS_OR_ROWS = 4,
    IS_INVALID_READ_END_CONDITION = 5
}

#endregion


#region Requests
public partial class ValidateFileReq
{
    public required String CorrelationId { get; set; }
    public required FileInfo FileInfo { get; set; }
}
    
public partial class GetInjestFilePropertyDetailsByApplicationOwnerReq
{
    public required String CorrelationId { get; set; }
    public required String ApplicationOwner { get; set; }
}
#endregion

#region Response
#region Base Response
    
public class BaseResponse
{
    public String CorrelationId { get; set; } = String.Empty;
    public HttpStatusCode StatusCode { get; set; } = HttpStatusCode.OK;
    public List<String> Errors { get; set; } = [];
}
#endregion

#region ValidateFile Response

public class ValidateFileRes
{
    public BaseResponse WebResp { get; set; } = new();
    public List<ParsedData> ParsedDataList { get; set; } = [];
}
#endregion

#region GetInjestFilePropertyDetailsRes
public class GetInjestFilePropertyDetailsByApplicationOwnerRes
{
    public BaseResponse WebResp { get; set; } = new();
    public required GetInjestFilePropertyDetailsByApplicationOwnerReq Req { get; set; }
    public List<InjestFileProperty> InjestFileProperties { get; set; } = [];
}
#endregion
#endregion

#region Exception
[Serializable]
public partial class SGBLBadRequestException : Exception
{
    public SGBLBadRequestException() { }

    public SGBLBadRequestException(String? message) : base(message) { }

    public SGBLBadRequestException(String? message, Exception inner) : base(message, inner) { }
}

[Serializable]
public partial class SGBLNotFoundException : Exception
{
    public SGBLNotFoundException() { }

    public SGBLNotFoundException(String? message) : base(message) { }

    public SGBLNotFoundException(String? message, Exception inner) : base(message, inner) { }
}

[Serializable]
public partial class SGBLInternalServerException : Exception
{
    public SGBLInternalServerException() { }

    public SGBLInternalServerException(String? message) : base(message) { }

    public SGBLInternalServerException(String? message, Exception inner) : base(message, inner) { }
}
#endregion
