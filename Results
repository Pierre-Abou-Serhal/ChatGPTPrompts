Cool — that’s just a small tweak in the `MaskKeepLast` helper.

Right now your logic does this:

```csharp
if (input.Length <= keepLast) return input;
```

That means “keep as-is if shorter/equal”.

You want the opposite behavior: **mask anyway**, even if shorter.
In that case, the “keep last N” operation should do this:

* If `len <= keepLast` → **mask all characters** (or mask all but keep last `len` which is the whole string… but that would keep everything, so not desired)
* If `len > keepLast` → mask all but last `keepLast`

So the rule becomes:

✅ `maskedCount = max(1? or 0?, len - keepLast)` but with “mask anyway” we want:

* when `len <= keepLast` → maskedCount = len (mask everything)
* when `len > keepLast` → maskedCount = len - keepLast

### Replace your `MaskKeepLast` in BOTH JsonMasker and XmlMasker with this version:

```csharp
private static string MaskKeepLast(string input, int keepLast, char maskChar)
{
    if (input is null) return string.Empty;

    // Normalize
    if (keepLast < 0) keepLast = 0;

    // If keepLast == 0 => mask everything
    if (keepLast == 0)
        return new string(maskChar, input.Length);

    // Mask anyway even if shorter:
    if (input.Length <= keepLast)
        return new string(maskChar, input.Length);

    // Normal case
    return new string(maskChar, input.Length - keepLast) + input[^keepLast..];
}
```

That’s it.

### What changes in behavior

* `"ABC"` with `KeepLast = 4` becomes `"***"` (masked), not `"ABC"`
* `"1234567890124128"` with `KeepLast = 4` becomes `"************4128"` (same as before)

---

### Optional: If you want to still keep *something* visible even if shorter

Some teams prefer “keep last min(len, keepLast)” but still mask at least 1 char. If that’s your intent instead, tell me and I’ll adjust.

But for your request (“mask anyway even if shorter”), the snippet above is the correct change.
