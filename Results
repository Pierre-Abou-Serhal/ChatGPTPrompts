You’re seeing that because **your “global name rule” (`Path: "password"`) always applies**, and your “password + Operation” rule is just *another* rule — it doesn’t stop the first one from running.

So the fix is: **when multiple rules target the same Path**, you need a clear precedence rule.

The cleanest approach:

### ✅ Treat `Operation` as a filter that can *override* generic rules

Rule precedence (recommended):

1. **Operation-specific rules** (match `callParams.Operation`) win
2. **Generic rules** (no `Operation`) apply only if no operation-specific rule exists for the same `Path`

That way:

* If you configured `{ Path: "password", Operation: "string" }`, it will only apply for that operation.
* And the generic `{ Path: "password" }` won’t “force-mask” it anymore.

---

## 1) Add a helper in BLL to filter rules for the current request

Before masking, filter `rules` based on the current request operation:

```csharp
private static List<MaskRule> GetEffectiveRules(List<MaskRule> allRules, string? requestOperation)
{
    requestOperation ??= string.Empty;

    // Rules matching the operation (or with no operation)
    var applicable = allRules
        .Where(r => string.IsNullOrWhiteSpace(r.Operation) ||
                    string.Equals(r.Operation, requestOperation, StringComparison.OrdinalIgnoreCase))
        .ToList();

    // If there is an operation-specific rule for a given Path,
    // remove the generic rule with the same Path.
    var opSpecificPaths = new HashSet<string>(
        allRules
            .Where(r => !string.IsNullOrWhiteSpace(r.Operation) &&
                        string.Equals(r.Operation, requestOperation, StringComparison.OrdinalIgnoreCase))
            .Select(r => r.Path),
        StringComparer.OrdinalIgnoreCase);

    applicable.RemoveAll(r =>
        string.IsNullOrWhiteSpace(r.Operation) &&
        opSpecificPaths.Contains(r.Path));

    return applicable;
}
```

---

## 2) Use it in your `CallProcedureAsync`

Replace:

```csharp
List<MaskRule> rules = currentOptions.Masking.Rules;
```

with:

```csharp
var rules = GetEffectiveRules(currentOptions.Masking.Rules, callParams.Operation);
```

Now masking only sees the “effective” rules.

---

## Why this solves your exact issue

Given two rules:

```json
{ "Path": "password", "Replacement": "***" },
{ "Path": "password", "Replacement": "***PWD***", "Operation": "PostTransfer" }
```

* For `callParams.Operation = "PostTransfer"`:

  * Both are applicable, but the generic one gets removed because there’s an operation-specific rule for the same `Path`.
  * ✅ Only operation-specific runs.

* For `callParams.Operation = "OtherOp"`:

  * Operation-specific rule is not applicable.
  * ✅ Generic rule runs.

---

## Optional upgrade (more powerful)

If you want the same behavior even when paths differ slightly (like `**.password` vs `password`), you can normalize paths before comparing. But your current usage suggests paths are identical when you intend override — so this works well.

---

If you want, I can also show you how to support:

* multiple operations per rule (`"Operation": ["A","B"]`)
* negation (`"Operation": "!PostTransfer"`)
* or “apply for all except …” patterns.










Perfect — make `Operation` an array like `"Operations": ["PostTransfer", "GetAddress"]` and filter rules based on whether the request’s `callParams.Operation` is in that list.

Below is a clean implementation that also keeps your current “override generic rule if an operation-specific rule exists for the same Path” behavior.

---

## 1) Update `MaskRule`

Replace:

```csharp
public String? Operation { get; init; } = null;
```

with:

```csharp
public List<string>? Operations { get; init; } = null; // or string[] if you prefer
```

So your rule becomes “operation-scoped” if `Operations` is not null/empty.

---

## 2) appsettings.json examples

### Generic (applies to all operations)

```json
{ "Path": "password", "Replacement": "***" }
```

### Applies only to some operations

```json
{ "Path": "password", "Replacement": "***PWD***", "Operations": ["PostTransfer", "Operation"] }
```

### KeepLast masking for certain operations

```json
{ "Path": "**.@id", "KeepLast": 4, "MaskChar": "*", "Operations": ["CreateCard", "ReplaceCard"] }
```

---

## 3) Filter rules in BLL (recommended place)

Add this helper in your BLL class:

```csharp
private static List<MaskRule> GetEffectiveRules(List<MaskRule> allRules, string? requestOperation)
{
    requestOperation ??= string.Empty;

    bool MatchesOperation(MaskRule r)
        => r.Operations == null || r.Operations.Count == 0
           || r.Operations.Any(op => string.Equals(op, requestOperation, StringComparison.OrdinalIgnoreCase));

    // 1) Keep only rules that match the request operation (or have no operation filter)
    var applicable = allRules.Where(MatchesOperation).ToList();

    // 2) If there is an operation-scoped rule for a Path, remove the generic rule with the same Path
    var opSpecificPaths = new HashSet<string>(
        allRules
            .Where(r => r.Operations is { Count: > 0 } && MatchesOperation(r))
            .Select(r => r.Path),
        StringComparer.OrdinalIgnoreCase);

    applicable.RemoveAll(r =>
        (r.Operations == null || r.Operations.Count == 0) &&
        opSpecificPaths.Contains(r.Path));

    return applicable;
}
```

Then change your current:

```csharp
List<MaskRule> rules = currentOptions.Masking.Rules;
```

to:

```csharp
List<MaskRule> rules = GetEffectiveRules(currentOptions.Masking.Rules, callParams.Operation);
```

✅ Now:

* Rules with no `Operations` apply to all operations **unless** overridden by an operation-scoped rule for the same `Path`.
* Rules with `Operations` apply only when the current request operation matches.

---

## 4) Backward compatibility (optional)

If you already have `"Operation": "X"` in config and don’t want to break it, you can keep both:

```csharp
public string? Operation { get; init; } = null;      // legacy
public List<string>? Operations { get; init; } = null;
```

And treat both as equivalent in `MatchesOperation`:

```csharp
bool MatchesOperation(MaskRule r)
{
    if (!string.IsNullOrWhiteSpace(r.Operation))
        return string.Equals(r.Operation, requestOperation, StringComparison.OrdinalIgnoreCase);

    return r.Operations == null || r.Operations.Count == 0
        || r.Operations.Any(op => string.Equals(op, requestOperation, StringComparison.OrdinalIgnoreCase));
}
```

---

If you want, I can also adjust the logic to support:

* “apply for all except X” (negation)
* wildcard operations (prefix match)
* multiple paths overriding (e.g., `password` and `**.password` treated the same via normalization)
