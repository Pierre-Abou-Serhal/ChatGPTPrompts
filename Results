using Microsoft.Extensions.DependencyInjection;
using ReverseProxy.Common;
using System.Net;
using System.Net.Security;
using System.Security.Cryptography.X509Certificates;
using Yarp.ReverseProxy.Configuration;

namespace ReverseProxy.Extensions
{
    public static class ReverseProxyExtensions
    {
        public static void AddConfiguredReverseProxy(this IServiceCollection services, IConfiguration configuration)
        {
            Certificate certificates = configuration.GetSection("Certificates").Get<Certificate>() ?? new();

            services.AddReverseProxy()
                .LoadFromConfig(configuration.GetSection("ReverseProxy"))
                .ConfigureHttpClient((context, handler) =>
                {
                    var clusterId = context.ClusterId;

                    ClientCertificate? clientCertificate = certificates.ClientCertificates
                        .FirstOrDefault(i => i.ClusterId.Equals(clusterId, StringComparison.OrdinalIgnoreCase));

                    if (clientCertificate is not null)
                    {
                        string certPath = Path.Combine(AppContext.BaseDirectory, clientCertificate.Path);
                        string certPassword = clientCertificate.Password;

                        var clientCert = new X509Certificate2(
                            certPath,
                            certPassword,
                            X509KeyStorageFlags.Exportable | X509KeyStorageFlags.PersistKeySet | X509KeyStorageFlags.UserKeySet);

                        if (!clientCert.HasPrivateKey)
                            throw new InvalidOperationException("Client certificate is missing a private key");

                        handler.SslOptions = new SslClientAuthenticationOptions
                        {
                            ClientCertificates = new X509CertificateCollection { clientCert },
                        };
                    }

                    WebProxy webProxy = new WebProxy(configuration["WebProxyAddress"]);
                    handler.Proxy = webProxy;
                    handler.UseProxy = true;
                });
        }
    }
}