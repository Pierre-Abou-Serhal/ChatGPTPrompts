I want to create a .Net Web API that have the following endpoints that will call theses APIs:

1- CreateSession:
  Request:
  {
  	"session": {
  		"authenticationLimit": 25
  	}
  }
  the endpoint to call: POST https://{{host}}/api/rest/version/100/merchant/{{merchantId}}/session
  host and merchant will be configured

  Response:
  {
    "merchant": "002M7270",
    "result": "SUCCESS",
    "session": {
        "aes256Key": "M/YzE59RoEy+fS8efdCtJz6J4QhV/JzzoZ+/pZzWtIA=",
        "authenticationLimit": 25,
        "id": "SESSION0002129947563N13816378N8",
        "updateStatus": "NO_UPDATE",
        "version": "4e7143bf01"
    }
}

The API use Basic Authorisation with username and password


----------------------------------------------------------

Awesome‚Äîhere‚Äôs a clean, production-ready template for a .NET 8 Minimal API that exposes a `POST /api/session` endpoint and forwards to the upstream ‚ÄúCreateSession‚Äù API using Basic Auth. Host, merchant ID, version, and credentials are configurable.

# Project layout

```
YourProject/
 ‚îú‚îÄ Program.cs
 ‚îú‚îÄ Gateway/
 ‚îÇ   ‚îú‚îÄ GatewayOptions.cs
 ‚îÇ   ‚îî‚îÄ GatewayClient.cs
 ‚îú‚îÄ Contracts/
 ‚îÇ   ‚îú‚îÄ CreateSessionRequest.cs
 ‚îÇ   ‚îî‚îÄ CreateSessionResponse.cs
 ‚îî‚îÄ appsettings.json
```

---

### `appsettings.json`

```json
{
  "Gateway": {
    "Host": "your-host.example.com",
    "MerchantId": "002M7270",
    "Version": "100",
    "Username": "YOUR_USERNAME",
    "Password": "YOUR_PASSWORD"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}
```

---

### `Contracts/CreateSessionRequest.cs`

```csharp
using System.Text.Json.Serialization;

namespace YourProject.Contracts;

public record CreateSessionRequest(
    [property: JsonPropertyName("session")] CreateSessionRequestBody Session
);

public record CreateSessionRequestBody(
    [property: JsonPropertyName("authenticationLimit")] int AuthenticationLimit
);
```

---

### `Contracts/CreateSessionResponse.cs`

```csharp
using System.Text.Json.Serialization;

namespace YourProject.Contracts;

public record CreateSessionResponse(
    [property: JsonPropertyName("merchant")] string Merchant,
    [property: JsonPropertyName("result")] string Result,
    [property: JsonPropertyName("session")] CreateSessionSession Session
);

public record CreateSessionSession(
    [property: JsonPropertyName("aes256Key")] string? Aes256Key,
    [property: JsonPropertyName("authenticationLimit")] int AuthenticationLimit,
    [property: JsonPropertyName("id")] string Id,
    [property: JsonPropertyName("updateStatus")] string UpdateStatus,
    [property: JsonPropertyName("version")] string Version
);
```

---

### `Gateway/GatewayOptions.cs`

```csharp
namespace YourProject.Gateway;

public sealed class GatewayOptions
{
    public string Host { get; set; } = default!;
    public string MerchantId { get; set; } = default!;
    public string Version { get; set; } = "100";
    public string Username { get; set; } = default!;
    public string Password { get; set; } = default!;
}
```

---

### `Gateway/GatewayClient.cs`

```csharp
using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;
using Microsoft.Extensions.Options;
using YourProject.Contracts;

namespace YourProject.Gateway;

public interface IGatewayClient
{
    Task<CreateSessionResponse> CreateSessionAsync(
        CreateSessionRequest request,
        CancellationToken ct = default);
}

public sealed class GatewayClient(IOptions<GatewayOptions> options, HttpClient http) : IGatewayClient
{
    private static readonly JsonSerializerOptions JsonOptions = new(JsonSerializerDefaults.Web);
    private readonly GatewayOptions _cfg = options.Value;
    private readonly HttpClient _http = http;

    public async Task<CreateSessionResponse> CreateSessionAsync(
        CreateSessionRequest request,
        CancellationToken ct = default)
    {
        // Build full URL: https://{host}/api/rest/version/{version}/merchant/{merchantId}/session
        var url = $"https://{_cfg.Host}/api/rest/version/{_cfg.Version}/merchant/{_cfg.MerchantId}/session";

        // Basic Auth
        var rawCreds = $"{_cfg.Username}:{_cfg.Password}";
        var b64 = Convert.ToBase64String(Encoding.UTF8.GetBytes(rawCreds));
        _http.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Basic", b64);

        using var content = new StringContent(JsonSerializer.Serialize(request, JsonOptions), Encoding.UTF8, "application/json");
        using var resp = await _http.PostAsync(url, content, ct);

        var body = await resp.Content.ReadAsStringAsync(ct);

        if (!resp.IsSuccessStatusCode)
        {
            // Bubble up upstream details but avoid leaking credentials
            throw new HttpRequestException($"Upstream error {(int)resp.StatusCode}: {body}");
        }

        var parsed = JsonSerializer.Deserialize<CreateSessionResponse>(body, JsonOptions);
        if (parsed is null)
            throw new InvalidOperationException("Failed to parse CreateSession response.");

        return parsed;
    }
}
```

---

### `Program.cs`

```csharp
using Microsoft.AspNetCore.Http.HttpResults;
using Microsoft.OpenApi.Models; // üîπ
using YourProject.Contracts;
using YourProject.Gateway;

var builder = WebApplication.CreateBuilder(args);

// Options
builder.Services.Configure<GatewayOptions>(builder.Configuration.GetSection("Gateway"));

// HttpClient
builder.Services.AddHttpClient<IGatewayClient, GatewayClient>();

// üîπ Swagger services
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen(c =>
{
    c.SwaggerDoc("v1", new OpenApiInfo
    {
        Title = "YourProject API",
        Version = "v1",
        Description = "Gateway API that forwards CreateSession to the upstream provider."
    });

    // Include XML comments (if enabled in csproj)
    var xml = $"{System.Reflection.Assembly.GetExecutingAssembly().GetName().Name}.xml";
    var xmlPath = System.IO.Path.Combine(AppContext.BaseDirectory, xml);
    if (System.IO.File.Exists(xmlPath))
    {
        c.IncludeXmlComments(xmlPath, includeControllerXmlComments: true);
    }

    // (Optional) Define Basic Auth scheme in case you later secure YOUR endpoint
    c.AddSecurityDefinition("basic", new OpenApiSecurityScheme
    {
        Name = "Authorization",
        Type = SecuritySchemeType.Http,
        Scheme = "basic",
        In = ParameterLocation.Header,
        Description = "Basic auth (enter your API credentials)."
    });
    c.AddSecurityRequirement(new OpenApiSecurityRequirement
    {
        {
            new OpenApiSecurityScheme{ Reference = new OpenApiReference{ Type = ReferenceType.SecurityScheme, Id = "basic" } },
            Array.Empty<string>()
        }
    });
});

var app = builder.Build();

// üîπ Swagger middleware
// Expose Swagger everywhere; switch to IsDevelopment() if you prefer dev-only.
app.UseSwagger();
app.UseSwaggerUI(c =>
{
    c.SwaggerEndpoint("/swagger/v1/swagger.json", "YourProject API v1");
    c.RoutePrefix = "swagger"; // UI at /swagger
});

// Endpoint
app.MapPost("/api/session", async Task<Results<Ok<CreateSessionResponse>, BadRequest<string>>> (
    /// <summary>Creates a session via the upstream gateway.</summary>
    /// <param name="request">Payload with session.authenticationLimit.</param>
    /// <returns>The upstream CreateSession response.</returns>
    CreateSessionRequest request,
    IGatewayClient client,
    CancellationToken ct) =>
{
    if (request?.Session is null || request.Session.AuthenticationLimit <= 0)
        return TypedResults.BadRequest("Invalid request: 'session.authenticationLimit' must be > 0.");

    try
    {
        var result = await client.CreateSessionAsync(request, ct);
        return TypedResults.Ok(result);
    }
    catch (HttpRequestException ex)
    {
        return TypedResults.BadRequest($"CreateSession failed: {ex.Message}");
    }
})
.WithName("CreateSession")               // üîπ Improves Swagger operation naming
.WithOpenApi();                          // üîπ Ensures it appears with inferred schema

app.Run();

```

---

## How to run

1. Create the project:

```bash
dotnet new web -n YourProject
```

Add the folders/files above (or `dotnet new webapi` if you prefer controllers).

2. Configure `appsettings.json` with your actual `Host`, `MerchantId`, `Username`, and `Password`.

3. Run:

```bash
dotnet run
```

---

## Example request (to **your** API)

```bash
curl -X POST http://localhost:5000/api/session \
  -H "Content-Type: application/json" \
  -d '{ "session": { "authenticationLimit": 25 } }'
```

### Example successful response (proxied from upstream)

```json
{
  "merchant": "002M7270",
  "result": "SUCCESS",
  "session": {
    "aes256Key": "M/YzE59RoEy+fS8efdCtJz6J4QhV/JzzoZ+/pZzWtIA=",
    "authenticationLimit": 25,
    "id": "SESSION0002129947563N13816378N8",
    "updateStatus": "NO_UPDATE",
    "version": "4e7143bf01"
  }
}
```

---

## Notes & options

* **Security**: Keep credentials in `appsettings.Development.json` or user-secrets locally; use environment variables in production.
* **Polly / resilience**: You can add retries/timeouts to the `HttpClient` if the upstream can be flaky.
* **Controllers instead of Minimal API**: If you prefer MVC, I can swap to a `SessionsController` sample.

If you want to add more endpoints that call other upstream APIs, tell me their specs and I‚Äôll extend this skeleton consistently.
