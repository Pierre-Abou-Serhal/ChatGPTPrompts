````md
# Logger API – Payload Masking Rules

This project supports masking sensitive data in **JSON** and **XML** payloads before they are logged to the database/file.  
Masking is configured through `AppConfig:Masking:Rules` in `appsettings.json`.

The goal is to allow teams to safely log payloads while preventing exposure of sensitive information (card numbers, CVV, tokens, passwords, IDs, etc.).

---

## Configuration Location

All masking rules live under:

```json
"AppConfig": {
  "Masking": {
    "Rules": [ ... ]
  }
}
````

---

## Rule Format

Each rule is a JSON object with a required `Path`, optional `Operations`, plus **one** masking mode.

### Optional — Restrict a rule to specific operations (`Operations`)

You can restrict a masking rule to only apply for certain request operations (based on the value of `request.Operation`).

✅ Use:

* `Operations`: an array of operation names

Example:

```json
{ "Path": "ContractIdentifier", "KeepLast": 4, "MaskChar": "*", "Operations": ["SetCardStatus", "ActivateCard"] }
```

Notes:

* If `Operations` is **missing** or an **empty array**, the rule applies to **all** operations.
* Operation matching is **case-insensitive** and must match the operation name **exactly**.

### Precedence (important)

If you have:

* a **generic rule** (no `Operations`) for the same `Path`, and
* an **operation-specific rule** (with `Operations`) for that same `Path`

Then:

* when the request operation matches the operation-specific rule, the **operation-specific rule overrides**, and the generic rule for that `Path` will **not** be applied.

---

## Masking Modes (choose one)

Each rule must use **exactly one** of the following modes:

### Mode A — Full Replacement

Use **`Replacement`** to replace the entire value.

✅ Use:

* `Path`
* `Replacement`

❌ Do **not** include:

* `KeepLast`
* `MaskChar`

Example:

```json
{ "Path": "password", "Replacement": "***" }
```

---

### Mode B — Keep Last N Characters

Use **`KeepLast` + `MaskChar`** to keep the last N characters and mask the rest.

✅ Use:

* `Path`
* `KeepLast`
* `MaskChar`

❌ Do **not** include:

* `Replacement`

Example:

```json
{ "Path": "**.card.number", "KeepLast": 4, "MaskChar": "*" }
```

Result example:

* Original: `5111111111117809`
* Masked: `************7809`

> **Important:** Masking is applied **even if the input is shorter than `KeepLast`** (it will still be masked).

---

## Path Syntax

Rules target fields using dot-separated paths with support for:

* nested paths
* arrays
* match-anywhere prefix (`**.`)
* XML attributes (`@`)

### 1) Mask by Name Anywhere (Global Name Rule)

If `Path` contains **no** dots (`.`) and **no** array tokens (`[]`), it is treated as:

> “Mask any field/element with this name anywhere in the payload.”

Example:

```json
{ "Path": "token", "Replacement": "***" }
{ "Path": "password", "Replacement": "***" }
```

This masks:

* any JSON property named `token` / `password` at any depth
* any XML element `<token>` / `<password>` at any depth

---

### 2) Rooted/Nested Path

Use dot notation to target a specific nested field:

```json
{ "Path": "A.B.C.password", "Replacement": "***" }
```

Only masks `password` under `A → B → C`.

---

### 3) Match Anywhere in the Tree with `**.`

Prefix a path with `**.` to apply it from any depth.
This is recommended when root wrappers differ between messages.

Example:

```json
{ "Path": "**.card.details.name", "Replacement": "***" }
{ "Path": "**.cards[*].holder.name", "Replacement": "***" }
```

Meaning:

> “Find this path anywhere in the payload and mask it.”

---

### 4) Arrays with `[*]`

Arrays are supported using `[*]`:

```json
{ "Path": "**.cards[*].cvv", "Replacement": "***" }
```

* **JSON**: masks all items inside the `cards` array
* **XML**: repeated elements with the same name behave like array items

---

### 5) XML Attributes with `@`

To mask **XML attributes**, use `@attributeName`.

#### Mask a specific attribute on a specific element:

```json
{ "Path": "**.CARDISSUESGBNEWVIRTUALCARDREQUESTType.@id", "Replacement": "***" }
```

#### Mask an attribute anywhere:

```json
{ "Path": "**.@id", "Replacement": "***" }
```

Example input:

```xml
<CARDISSUESGBNEWVIRTUALCARDREQUESTType id="5111111111117809/TCIB.REG-123456">
```

Rule:

```json
{ "Path": "**.@id", "KeepLast": 4, "MaskChar": "*" }
```

Output:

```xml
<CARDISSUESGBNEWVIRTUALCARDREQUESTType id="************************3456">
```

> Notes:
>
> * `@` syntax is for **XML attributes** and will also mask **JSON properties** named like `@id`.
> * Example JSON: `"CARDISSUESGBNEWVIRTUALCARDREQUESTType": { "@id": "5111111111117809/TCIB.REG-123456" }` → `@id` will be masked.

---

## Example appsettings.json

```json
{
  "AppConfig": {
    "Masking": {
      "Rules": [
        { "Path": "**.card.details.name", "Replacement": "***" },
        { "Path": "**.cards[*].holder.name", "Replacement": "***" },
        { "Path": "**.cards[*].cvv", "Replacement": "***" },

        { "Path": "password", "Replacement": "***" },
        { "Path": "token", "Replacement": "***" },

        { "Path": "**.card.number", "KeepLast": 4, "MaskChar": "*" },
        { "Path": "**.@id", "KeepLast": 4, "MaskChar": "*" },

        { "Path": "ContractIdentifier", "KeepLast": 4, "MaskChar": "*", "Operations": ["SetCardStatus"] }
      ]
    }
  }
}
```

---

## Best Practices

* Use `**.` when root object names vary between services/integrations.
* Use global name rules (`"password"`, `"token"`, `"cvv"`) to ensure broad coverage.
* Use `KeepLast` for identifiers where you still need partial visibility (card number last 4, transaction id suffix, etc.).
* Use `Operations` when masking requirements differ by operation.

---

## Troubleshooting

### “Only password/token are masked”

If your rule uses a rooted path like `card.number` but your JSON has a wrapper root (e.g. `Response.card.number`), it won’t match unless:

* you use the full rooted path, **or**
* you prefix it with `**.` to match from anywhere.

✅ Prefer:

```json
{ "Path": "**.card.number", "KeepLast": 4, "MaskChar": "*" }
```

### “My operation-specific rule isn’t applied”

* Ensure `request.Operation` matches one of the values in `Operations` exactly (case-insensitive).
* If you have both a generic rule and an operation-specific rule for the same `Path`, the operation-specific rule overrides the generic rule when it matches.

---

## Summary Cheat Sheet

| Goal                                    | Example Path                                           |
| --------------------------------------- | ------------------------------------------------------ |
| Mask by name anywhere                   | `password`                                             |
| Mask nested field                       | `A.B.C.password`                                       |
| Match anywhere                          | `**.card.details.name`                                 |
| Mask all array items                    | `**.cards[*].cvv`                                      |
| Mask XML attribute anywhere             | `**.@id`                                               |
| Keep last digits                        | `**.card.number` + `KeepLast`                          |
| Apply rule only for specific operations | `ContractIdentifier` + `Operations: ["SetCardStatus"]` |

---

```
```
