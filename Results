Yes — and the **best pattern** here is:

* Add an **Edit** button in the duplicate modal row
* When clicked, **close the duplicate modal** with a result like `{ action: 'edit', id }`
* In the **parent**, catch that result, open your existing `EditDataComponent` (same logic as today), then **re-open the duplicate modal** to continue the validation flow

That way:

* you reuse your existing edit logic
* the parent remains the owner of `fileImport` + DataTables updates
* the user can edit duplicates and then continue validation

---

## 1) Update `DuplicateAccNbr` model (add `id`)

You need the row `id` to edit the exact record.

```ts
export interface DuplicateAccNbr {
  id: number;
  accNbr: string;
  amount: number;
  other?: string;
}
```

---

## 2) Update `getDuplicatedAccNbrs()` in parent (include `id`)

```ts
private getDuplicatedAccNbrs(items: FileImportContent[]): DuplicateAccNbr[] {
  const counts = new Map<string, number>();

  for (const item of items) {
    const acc = item.accNbr?.trim();
    if (!acc) continue;
    counts.set(acc, (counts.get(acc) ?? 0) + 1);
  }

  return items
    .map((item): DuplicateAccNbr => ({
      id: item.id,
      accNbr: item.accNbr?.trim() ?? '',
      amount: item.amount,
      other: item.other,
    }))
    .filter((item) => !!item.accNbr && (counts.get(item.accNbr) ?? 0) > 1)
    .sort((a, b) => a.accNbr.localeCompare(b.accNbr) || b.amount - a.amount);
}
```

---

## 3) Add Edit action to the duplicate modal component

### `duplicate-accounts-modal.component.ts`

```ts
import { Component, Input } from '@angular/core';
import { CommonModule } from '@angular/common';
import { NgbActiveModal } from '@ng-bootstrap/ng-bootstrap';
import { DuplicateAccNbr } from '../../../../../Services/Models/custom-models';
import { DataTablesModule } from 'angular-datatables';
import { Config } from 'datatables.net';

@Component({
  selector: 'app-duplicate-accounts-modal',
  standalone: true,
  imports: [CommonModule, DataTablesModule],
  templateUrl: './duplicate-accounts-modal.component.html',
  styleUrl: './duplicate-accounts-modal.component.scss',
})
export class DuplicateAccountsModalComponent {
  @Input() duplicates: DuplicateAccNbr[] = [];

  constructor(public activeModal: NgbActiveModal) {}

  dtOptions: Config = {
    pagingType: 'full_numbers',
    pageLength: 10,
    responsive: true,
    order: [[0, 'asc']],
    dom: 'Blfrtip',
    scrollY: '320px',        // vertical scroll
    scrollCollapse: true,
    buttons: [
      {
        extend: 'excelHtml5',
        text: 'Excel',
        filename: `${new Date().toDateString()}`,
      },
    ],
  };

  onNo(): void {
    this.activeModal.dismiss('cancel');
  }

  onYesContinue(): void {
    this.activeModal.close('continue');
  }

  onEdit(item: DuplicateAccNbr): void {
    this.activeModal.close({
      action: 'edit',
      id: item.id,
    });
  }
}
```

---

## 4) Add the Edit button column in the duplicate modal HTML

### `duplicate-accounts-modal.component.html`

```html
<div class="modal-header">
  <h4 class="modal-title">Duplicate Proposed Account Numbers Found</h4>
  <button type="button" class="btn-close" (click)="onNo()"></button>
</div>

<div class="modal-body">
  <div class="alert alert-warning">
    Duplicate proposed account numbers were found. Do you want to continue?
  </div>

  <div *ngIf="!duplicates || duplicates.length === 0" class="alert alert-info mb-0">
    No duplicate account numbers found.
  </div>

  <div *ngIf="duplicates && duplicates.length > 0" class="table-responsive with-excel-button">
    <table
      datatable
      [dtOptions]="dtOptions"
      class="table table-bordered table-striped mb-0"
    >
      <thead>
        <tr>
          <th class="text-start">Duplicate Account Number</th>
          <th class="text-start">Other</th>
          <th class="text-start">Amount</th>
          <th class="text-start">Actions</th>
        </tr>
      </thead>
      <tbody>
        <tr *ngFor="let item of duplicates">
          <td class="text-start">{{ item.accNbr }}</td>
          <td class="text-start">{{ item.other || '-' }}</td>
          <td class="text-start">{{ item.amount | number : '1.0-20' }}</td>
          <td class="text-start">
            <button
              type="button"
              class="btn btn-sm edit-btn"
              title="Edit"
              (click)="onEdit(item)"
            >
              <i class="bi bi-pencil-square"></i>
            </button>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
</div>

<div class="modal-footer">
  <button type="button" class="btn btn-danger" (click)="onNo()">No</button>
  <button type="button" class="btn btn-success" (click)="onYesContinue()">Yes</button>
</div>
```

---

## 5) Add modal button style (important)

Your `.edit-btn` style is in the **parent component SCSS**, so it will **not** apply inside the modal component.

Create `duplicate-accounts-modal.component.scss` (or copy to global styles):

```scss
.edit-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  background-color: #f8f9fa;
  border: 1px solid #ccc;
  color: #6c757d;
  transition: all 0.3s ease;

  &:hover {
    background-color: #6c757d;
    color: #ffffff;
    border-color: #6c757d;
  }

  i {
    font-size: 16px;
  }
}
```

---

## 6) Refactor parent validation flow to handle `"edit"` result and reopen modal

### Replace your duplicate-check block in `validateFile()` with a helper call:

```ts
this.handleDuplicateAccountsBeforeValidation(request);
```

---

### Add this helper method in parent component

```ts
private handleDuplicateAccountsBeforeValidation(request: ValidateFileRequest): void {
  const dupes = this.getDuplicatedAccNbrs(this.fileImport?.fileImportContents ?? []);

  if (dupes.length === 0) {
    this.validateFileApiCall(request);
    return;
  }

  const modalRef = this.modalService.open(DuplicateAccountsModalComponent, {
    size: 'lg',
    backdrop: 'static',
    centered: true,
    keyboard: false,
  });

  modalRef.componentInstance.duplicates = dupes;

  modalRef.result
    .then(async (result) => {
      if (result === 'continue') {
        this.validateFileApiCall(request);
        return;
      }

      if (result?.action === 'edit' && result?.id) {
        const rowIndex =
          this.fileImport?.fileImportContents?.findIndex((x) => x.id === result.id) ?? -1;

        if (rowIndex >= 0) {
          await this.openEditDataModal(rowIndex, result.id);
        }

        // Re-check duplicates after edit and show modal again if needed
        this.handleDuplicateAccountsBeforeValidation(request);
      }
    })
    .catch(() => {
      // No / dismissed => do nothing
    });
}
```

---

## 7) Make `openEditDataModal()` return a Promise (so parent can await it)

You can keep your logic exactly the same, just return the modal promise.

```ts
openEditDataModal(index: number, id: number): Promise<FileImportContent | undefined> {
  const modalRef = this.modalService.open(EditDataComponent, {
    size: 'lg',
    backdrop: 'static',
  });

  const current: FileImportContent =
    this.fileImport?.fileImportContents?.find((i) => i.id === id)!;

  modalRef.componentInstance.fileImport = this.fileImport;
  modalRef.componentInstance.fileImportContent = {
    id: current.id,
    fileImportId: current.fileImportId,
    altAccNbr: current.altAccNbr,
    accNbr: current.accNbr,
    amount: current.amount,
    statusId: current.statusId,
    validationRejectReason: current.validationRejectReason,
    productCode: current.productCode,
    productDescription: current.productDescription,
    customerName: current.customerName,
    other: current.other,
  };

  return modalRef.result
    .then((updatedRecord: FileImportContent) => {
      this.toastr.success(`Data Updated Successfully`, `Data Updated`, {
        closeButton: true,
        enableHtml: true,
        progressBar: true,
        timeOut: 800,
        easing: 'ease-in',
        easeTime: 200,
      });

      const updateData = {
        1: updatedRecord.accNbr ? updatedRecord.accNbr : '',
        3: updatedRecord.productDescription ? updatedRecord.productDescription : '',
        4: updatedRecord.customerName ? updatedRecord.customerName : '',
        8: updatedRecord.statusId,
      };

      const found = this.fileImport?.fileImportContents?.find(
        (item) => item.id == updatedRecord.id
      );

      if (found) Object.assign(found, updatedRecord);

      this.updateRowData(index, updateData);

      return updatedRecord;
    })
    .catch(() => undefined);
}
```

---

## 8) In `validateFile()`, final usage becomes clean

Replace your current duplicate block with:

```ts
this.handleDuplicateAccountsBeforeValidation(request);
```

So your `validateFile()` stays simple.

---

## Best grouping approach (without losing details)

Since you asked earlier: the best UX is still to **sort by `accNbr`** (which you already do), and if needed later you can upgrade to **grouped rows**.

For now, because you’re using **DataTables** and want **Edit** per row, the flat sorted list is actually the most practical choice.

If you want, I can give you a version with:

* **group headers per account number** (while still keeping Edit buttons on each row)
* or a **count badge** next to each account number (e.g. `123456 (3)`) without losing detail rows
