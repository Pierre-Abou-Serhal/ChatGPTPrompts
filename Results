using Yarp.ReverseProxy.Configuration;
using System.Net;
using System.Net.Security;
using System.Security.Cryptography.X509Certificates;
using Serilog;

// Detect if the app is running as a Windows service
var isWindowsService = !Environment.UserInteractive;

if (isWindowsService)
{
    var pathToContentRoot = AppContext.BaseDirectory;
    Directory.SetCurrentDirectory(pathToContentRoot);
}

Directory.CreateDirectory(Path.Combine(Directory.GetCurrentDirectory(), "logs"));

WebApplicationBuilder builder = WebApplication.CreateBuilder(args);

if (OperatingSystem.IsWindows())
{
    builder.Host.UseWindowsService();
}

#region Serilog Configuration
// Creating The Serilog Logger
Log.Logger = new LoggerConfiguration()
    .ReadFrom.Configuration(builder.Configuration)
    .CreateLogger();

builder.Host.UseSerilog();
#endregion

// CORS config (unchanged)
builder.Services.AddCors(options =>
{
    options.AddPolicy("CorsPolicyConfig",
        builder => builder
            .AllowAnyOrigin()
            .AllowAnyMethod()
            .AllowAnyHeader());
});

// Add YARP with proxy-aware HttpMessageHandler
builder.Services.AddReverseProxy()
    .LoadFromConfig(builder.Configuration.GetSection("ReverseProxy"))
    .ConfigureHttpClient((context, handler) =>
    {
        var clusterId = context.ClusterId;

        if (clusterId == "visaDirectCluster")
        {
            // Load your client certificate from file
            String certPath = Path.Combine(
                AppContext.BaseDirectory,
                builder.Configuration["ClientCertificates:VisaDirect:Path"] ?? throw new ArgumentException("Client certificate path is missing from configuration"));
            String certPassword = builder.Configuration["ClientCertificates:VisaDirect:Password"] ?? throw new ArgumentException("Client certificate password is missing from configuration");

            var clientCert = new X509Certificate2(
                certPath, 
                certPassword, 
                X509KeyStorageFlags.Exportable | X509KeyStorageFlags.PersistKeySet | X509KeyStorageFlags.UserKeySet);
            
            if (!clientCert.HasPrivateKey)
                throw new InvalidOperationException("Client certificate is missing a private key");
            
            handler.SslOptions = new SslClientAuthenticationOptions
            {
                ClientCertificates = new X509CertificateCollection { clientCert },
            };
        }
        
        WebProxy webProxy = new WebProxy(builder.Configuration.GetSection("WebProxyAddress").Value);
        
        handler.Proxy = webProxy;
        handler.UseProxy = true;
    });

WebApplication app = builder.Build();

app.UseCors("CorsPolicyConfig");
// Middleware to log incoming requests and outgoing responses
app.Use(async (context, next) =>
{
    var logger = context.RequestServices.GetRequiredService<ILogger<Program>>();

    logger.LogInformation("Request Received: {Method} {Path}{QueryString}",
        context.Request.Method, context.Request.Path, context.Request.QueryString);

    // Enable buffering for request body
    context.Request.EnableBuffering();

    if (context.Request.ContentLength > 0 && context.Request.Body.CanSeek)
    {
        context.Request.Body.Position = 0;
        using var reader = new StreamReader(context.Request.Body, leaveOpen: true);
        var body = await reader.ReadToEndAsync();
        logger.LogInformation("Request Body: {Body}", body);
        context.Request.Body.Position = 0; // Rewind for YARP to read
    }

    // Capture original response body stream
    var originalBodyStream = context.Response.Body;
    await using var responseBody = new MemoryStream();
    context.Response.Body = responseBody;

    await next(); // Continue pipeline, including proxy

    // Log response status
    logger.LogInformation("Response Status: {StatusCode}", context.Response.StatusCode);

    // Read and log response body
    responseBody.Seek(0, SeekOrigin.Begin);
    string responseText = await new StreamReader(responseBody).ReadToEndAsync();
    logger.LogInformation("Response Body: {Body}", responseText);

    // Copy response back to original stream
    responseBody.Seek(0, SeekOrigin.Begin);
    await responseBody.CopyToAsync(originalBodyStream);
});
app.UseHttpsRedirection();
app.UseRouting();
app.MapReverseProxy();

app.Run();
