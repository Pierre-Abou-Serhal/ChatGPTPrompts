{
  "Urls": "https://localhost:7217",
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "AppConfig": {
    "ConnectionString": "Data Source=DEV-SQL2016\\PERFAPP;Initial Catalog=Alterna.Logger;User ID=sasadmin;Password=sasadmin;TrustServerCertificate=True;",
    "InfoLogSP": "usp_LogInfo",
    "ErrorLogSP": "usp_LogError",
    "InternalLogSP": "usp_LogInternal",
    "FileLogs": "C:\\Logs\\InternalLogFallBack.txt",
    "Masking": {
      "Rules": [
        { "Path": "**.card.details.name", "Replacement": "***MASKED_DETAILS_NAME***" },
        { "Path": "WSSOGEIBMBGETADDRESSResponse.ESGBGLOBALBBType.gESGBGLOBALBBDetailType.card.number", "MaskChar": "X", "KeepLast": 4 },
        { "Path": "WSSOGEIBMBGETADDRESSResponse.ESGBGLOBALBBType.gESGBGLOBALBBDetailType.cards[*].cvv", "MaskChar": "~", "KeepLast": 1 },
        { "Path": "**.cards[*].holder.name", "Replacement": "MASKED_HOLDER_NAME" },

        { "Path": "password", "Replacement": "***", "Operation": "string" },
        { "Path": "token", "MaskChar": "$", "KeepLast": 100 },
        { "Path": "**.CARDISSUESGBNEWVIRTUALCARDREQUESTType.@id", "Replacement": "**********" }
      ]
    }
  }
}


using System.Xml.Linq;
using Microsoft.Extensions.Options;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace BLL;


public class BLL(IOptionsMonitor<AppConfig> optionsMonitor)
{
    public async Task CallProcedureAsync(ParamsCallProcedure callParams)
    {
        var isError = false;

        AppConfig currentOptions = optionsMonitor.CurrentValue;
        List<MaskRule> rules = currentOptions.Masking.Rules;

        if (callParams.MsgXML != "N/A")
        {
            try
            {
                var xdoc = XDocument.Parse(callParams.MsgXML);
                // var root = RemoveAllNamespaces(xdoc.Root!);

                // Mask XML
                var maskedXml = XmlMasker.MaskXml(xdoc.Root!.ToString(SaveOptions.DisableFormatting), rules);
                callParams.MsgXML = maskedXml;

                // Recompute JSON from masked XML (so JSON matches what was logged)
                var maskedRoot = RemoveAllNamespaces(XDocument.Parse(maskedXml).Root!);
                callParams.MsgJSON = JsonConvert.SerializeXNode(maskedRoot, Formatting.Indented, true);

                // If you also want to apply JSON-only rules (when MsgJSON comes from elsewhere), do:
                callParams.MsgJSON = JsonMasker.MaskJson(callParams.MsgJSON, rules);
            }
            catch (Exception ex)
            {
                isError = true;
                callParams.MsgJSON = ex.Message + "\n" + ex.StackTrace;
            }
        }
        else
        {
            // if MsgJSON is populated independently sometimes:
            callParams.MsgJSON = JsonMasker.MaskJson(callParams.MsgJSON, rules);
        }

        DAL.DAL.AppConfig dalOptions = new()
        {
            ConnectionString = currentOptions.ConnectionString,
            InfoLogSp = currentOptions.InfoLogSp,
            ErrorLogSp = currentOptions.ErrorLogSp,
            InternalLogSp = currentOptions.InternalLogSp,
            FileLogs = currentOptions.FileLogs
        };

        DAL.DAL dal = new(dalOptions);

        if (!isError)
            await dal.DatabaseLogAsync(
                callParams.CorolationId,
                callParams.AppName,
                callParams.AppUser,
                callParams.LoggingEntity,
                callParams.RequestDirection,
                callParams.RequestType,
                callParams.Operation,
                callParams.Path,
                callParams.URL,
                callParams.ReservedOne,
                callParams.ReservedTwo,
                callParams.MsgXML,
                callParams.MsgJSON,
                callParams.ErrorCode,
                callParams.IsError
            );
        else
            await dal.InternalErrorLogAsync(
                callParams.CorolationId,
                callParams.AppName,
                callParams.AppUser,
                callParams.LoggingEntity,
                callParams.RequestDirection,
                callParams.RequestType,
                callParams.Operation,
                callParams.Path,
                callParams.URL,
                callParams.ReservedOne,
                callParams.ReservedTwo,
                callParams.MsgXML,
                callParams.MsgJSON,
                "XML Parsing Error",
                callParams.MsgJSON
            );
    }

    private static XElement RemoveAllNamespaces(XElement element)
    {
        if (element.HasElements)
            return new XElement(element.Name.LocalName,
                element.Elements().Select(RemoveAllNamespaces),
                element.Attributes().Where(a => !a.IsNamespaceDeclaration));

        return new XElement(element.Name.LocalName,
            element.Attributes().Where(a => !a.IsNamespaceDeclaration),
            element.Value);
    }
}


public class AppConfig
{
    public String ConnectionString { get; init; } = String.Empty;
    public String InfoLogSp { get; set; } = "usp_LogInfo";
    public String ErrorLogSp { get; set; } = "usp_LogError";
    public String InternalLogSp { get; set; } = "usp_LogInternal";
    public String FileLogs { get; init; } = "InternalLogFallBack.txt";
    
    public MaskingOptions Masking { get; init; } = new();
}

public class MaskingOptions
{
    public List<MaskRule> Rules { get; init; } = [];
}

public class MaskRule
{
    public String Path { get; init; } = "";
    public String Replacement { get; init; } = "***";
    public Int64? KeepLast { get; init; } = null;     // e.g. 4
    public String MaskChar { get; init; } = "*";      // optional
    public String? Operation { get; init; } = null;
}

/// <summary>
///     Represents the parameters required to execute the logging stored procedure.
/// </summary>
public class ParamsCallProcedure
{
    public required String CorolationId { get; set; }
    public required String AppName { get; set; }
    public required String AppUser { get; set; }
    public required String LoggingEntity { get; set; }
    public String RequestDirection { get; set; } = "N/A";
    public String RequestType { get; set; } = "N/A";
    public String Operation { get; set; } = "N/A";
    public String Path { get; set; } = "N/A";
    public String URL { get; set; } = "N/A";
    public String ReservedOne { get; set; } = "N/A";
    public String ReservedTwo { get; set; } = "N/A";
    public String MsgXML { get; set; } = "N/A";
    public String MsgJSON { get; set; } = "N/A";
    public String? ErrorCode { get; set; } = null;
    public Boolean IsError { get; set; } = false;
}


#region Mask properties
internal readonly record struct PathToken(String Name, Int32? Index, Boolean AllItems);

internal static class MaskPath
{
    public static List<PathToken> Parse(String path)
    {
        var parts = path.Split('.', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);

        var tokens = new List<PathToken>(parts.Length);
        foreach (var part in parts)
        {
            if (part.StartsWith("@"))
            {
                tokens.Add(new PathToken(part, null, false));
                continue;
            }

            var open = part.IndexOf('[');
            if (open < 0)
            {
                tokens.Add(new PathToken(part, null, false));
                continue;
            }

            var close = part.IndexOf(']', open + 1);
            if (close < 0) throw new FormatException($"Invalid path token: {part}");

            var name = part[..open];
            var idxText = part[(open + 1)..close];

            if (idxText == "*" || idxText == "")
            {
                tokens.Add(new PathToken(name, null, true));
            }
            else if (Int32.TryParse(idxText, out var idx))
            {
                tokens.Add(new PathToken(name, idx, false));
            }
            else
            {
                throw new FormatException($"Invalid array index in token: {part}");
            }
        }

        return tokens;
    }
}

public static class JsonMasker
{
    public static String MaskJson(String json, IEnumerable<MaskRule> rules)
    {
        if (String.IsNullOrWhiteSpace(json) || json == "N/A") return json;

        var root = JToken.Parse(json);

        foreach (var rule in rules)
        {
            ApplyRule(root, rule);
        }

        return root.ToString(Formatting.Indented);
    }

    private static void ApplyRule(JToken root, MaskRule rule)
    {
        if (String.IsNullOrWhiteSpace(rule.Path)) return;

        if (!rule.Path.Contains('.') && !rule.Path.Contains('[') && !rule.Path.StartsWith("**.", StringComparison.Ordinal))
        {
            MaskAllPropertiesNamed(root, rule.Path, rule);
            return;
        }

        if (rule.Path.StartsWith("**.", StringComparison.Ordinal))
        {
            var trimmed = rule.Path[3..]; // remove "**."
            var tokens = MaskPath.Parse(trimmed);
            ApplyTokensFromAnywhere(root, tokens, rule);
            return;
        }

        var normalTokens = MaskPath.Parse(rule.Path);
        ApplyTokens(root, normalTokens, 0, rule);
    }

    private static void ApplyTokens(JToken current, List<PathToken> tokens, Int32 i, MaskRule rule)
    {
        if (i >= tokens.Count)
        {
            ReplaceValue(current, rule);
            return;
        }

        var t = tokens[i];

        if (current is JObject obj)
        {
            if (!obj.TryGetValue(t.Name, out var child))
                return;

            HandleChild(child, tokens, i, rule, t);
            return;
        }

        if (current is JArray arr)
        {
            foreach (var item in arr)
                ApplyTokens(item, tokens, i, rule);
        }
    }

    private static void ApplyTokensFromAnywhere(JToken root, List<PathToken> tokens, MaskRule rule)
    {
        ApplyTokens(root, tokens, 0, rule);

        foreach (var node in root.DescendantsAndSelfJson())
        {
            if (node is JObject || node is JArray)
                ApplyTokens(node, tokens, 0, rule);
        }
    }

    private static IEnumerable<JToken> DescendantsAndSelfJson(this JToken node)
    {
        yield return node;
        foreach (var child in node.Children())
        foreach (var d in child.DescendantsAndSelfJson())
            yield return d;
    }
    
    private static void HandleChild(JToken child, List<PathToken> tokens, Int32 i, MaskRule rule, PathToken t)
    {
        if (t.AllItems)
        {
            if (child is JArray a)
                foreach (var item in a) ApplyTokens(item, tokens, i + 1, rule);
            return;
        }

        if (t.Index is not null)
        {
            if (child is JArray a && t.Index.Value >= 0 && t.Index.Value < a.Count)
                ApplyTokens(a[t.Index.Value]!, tokens, i + 1, rule);
            return;
        }

        ApplyTokens(child, tokens, i + 1, rule);
    }

    private static void ReplaceValue(JToken token, MaskRule rule)
    {
        if (token is JValue v)
        {
            var currentText = v.Value?.ToString();
            v.Value = ApplyRuleToText(currentText, rule);
            return;
        }

        if (token.Parent is JProperty p)
        {
            var currentText = p.Value?.ToString();
            p.Value = ApplyRuleToText(currentText, rule);
        }
    }

    private static void MaskAllPropertiesNamed(JToken root, String propName, MaskRule rule)
    {
        switch (root)
        {
            case JObject obj:
            {
                foreach (var property in obj.Properties().ToList())
                {
                    if (String.Equals(property.Name, propName, StringComparison.OrdinalIgnoreCase))
                    {
                        var currentText = property.Value?.ToString();
                        property.Value = ApplyRuleToText(currentText, rule);
                    }
                    else
                    {
                        MaskAllPropertiesNamed(property.Value, propName, rule);
                    }
                }
                break;
            }

            case JArray arr:
            {
                foreach (var item in arr)
                    MaskAllPropertiesNamed(item, propName, rule);
                break;
            }
        }
    }
    
    private static String MaskKeepLast(String input, Int32 keepLast, Char maskChar)
    {
        if (input is null) return String.Empty;

        // Normalize
        if (keepLast < 0) keepLast = 0;

        // If keepLast == 0 => mask everything
        if (keepLast == 0)
            return new String(maskChar, input.Length);

        // Mask anyway even if shorter:
        if (input.Length <= keepLast)
            return new String(maskChar, input.Length);

        // Normal case
        return new String(maskChar, input.Length - keepLast) + input[^keepLast..];
    }

    private static String ApplyRuleToText(String? currentText, MaskRule rule)
    {
        if (currentText is null) return rule.Replacement;

        if (rule.KeepLast is > 0)
        {
            Char maskChar = !String.IsNullOrEmpty(rule.MaskChar) ? rule.MaskChar[0] : '*';
            return MaskKeepLast(currentText, (Int32)rule.KeepLast.Value, maskChar);
        }

        return rule.Replacement;
    }
}

public static class XmlMasker
{
    public static String MaskXml(String xml, IEnumerable<MaskRule> rules)
    {
        if (String.IsNullOrWhiteSpace(xml) || xml == "N/A") return xml;

        var doc = XDocument.Parse(xml);
        if (doc.Root is null) return xml;

        foreach (var rule in rules)
        {
            ApplyRule(doc.Root, rule);
        }

        return doc.ToString(SaveOptions.DisableFormatting);
    }

    private static void ApplyRule(XElement root, MaskRule rule)
    {
        if (String.IsNullOrWhiteSpace(rule.Path)) return;

        var originalPath = rule.Path;
        var path = originalPath;

        // match anywhere
        var isAnywhere = path.StartsWith("**.", StringComparison.Ordinal);
        if (isAnywhere)
            path = path[3..];

        // attribute-only rule like "@id"
        if (path.StartsWith("@", StringComparison.Ordinal) &&
            !path.Contains('.') && !path.Contains('['))
        {
            var attrName = path[1..]; // remove '@'

            foreach (var el in root.DescendantsAndSelf())
            {
                var attr = el.Attribute(attrName);
                if (attr is not null)
                    attr.Value = ApplyRuleToText(attr.Value, rule);
            }

            return;
        }

        // element-only rule
        if (!path.Contains('.') && !path.Contains('[') && !path.StartsWith("@", StringComparison.Ordinal))
        {
            foreach (var el in root.DescendantsAndSelf().Where(e =>
                         String.Equals(e.Name.LocalName, path, StringComparison.OrdinalIgnoreCase)))
            {
                el.Value = ApplyRuleToText(el.Value, rule);
            }
            return;
        }

        var tokens = MaskPath.Parse(path);

        // If original rule started with "**.", try applying from every node
        if (isAnywhere)
        {
            foreach (var start in root.DescendantsAndSelf())
                ApplyTokens(start, tokens, 0, rule);

            return;
        }

        ApplyTokens(root, tokens, 0, rule);
    }

    private static void ApplyTokens(XElement current, List<PathToken> tokens, Int32 i, MaskRule rule)
    {
        if (i >= tokens.Count)
        {
            current.Value = ApplyRuleToText(current.Value, rule);
            return;
        }

        var t = tokens[i];

        // Attribute support: token like "@id"
        if (t.Name.StartsWith("@"))
        {
            var attrName = t.Name[1..];

            var attr = current.Attributes()
                .FirstOrDefault(a => String.Equals(a.Name.LocalName, attrName, StringComparison.OrdinalIgnoreCase));

            if (attr is not null)
                attr.Value = ApplyRuleToText(attr.Value, rule);

            return;
        }

        // find matching children by local name
        var matches = current.Elements()
            .Where(e => String.Equals(e.Name.LocalName, t.Name, StringComparison.OrdinalIgnoreCase))
            .ToList();

        if (matches.Count == 0) return;

        if (t.AllItems)
        {
            foreach (var m in matches)
                ApplyTokens(m, tokens, i + 1, rule);
            return;
        }

        if (t.Index is not null)
        {
            var idx = t.Index.Value;
            if (idx >= 0 && idx < matches.Count)
                ApplyTokens(matches[idx], tokens, i + 1, rule);
            return;
        }

        // normal element step (if multiple matches, apply to all)
        foreach (var m in matches)
            ApplyTokens(m, tokens, i + 1, rule);
    }

    private static String MaskKeepLast(String input, Int32 keepLast, Char maskChar)
    {
        if (input is null) return String.Empty;

        // Normalize
        if (keepLast < 0) keepLast = 0;

        // If keepLast == 0 => mask everything
        if (keepLast == 0)
            return new String(maskChar, input.Length);

        // Mask anyway even if shorter:
        if (input.Length <= keepLast)
            return new String(maskChar, input.Length);

        // Normal case
        return new String(maskChar, input.Length - keepLast) + input[^keepLast..];
    }

    private static String ApplyRuleToText(String? currentText, MaskRule rule)
    {
        if (currentText is null) return rule.Replacement;

        if (rule.KeepLast is > 0)
        {
            var maskChar = !String.IsNullOrEmpty(rule.MaskChar) ? rule.MaskChar[0] : '*';
            return MaskKeepLast(currentText, (Int32)rule.KeepLast.Value, maskChar);
        }

        return rule.Replacement;
    }
}

#endregion
