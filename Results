Yes — absolutely.

Since your procedure is filtered by **one** `@NewCustomerId`, you can compute the DOB once at the top (and the swapped version too), then reuse it in the `WHERE`.

## Option 1 (simple): use local variables at the beginning

Add this near the top of the procedure (after `SET NOCOUNT ON;`):

```sql
DECLARE @NewDob nvarchar(20);
DECLARE @NewDobSwapped nvarchar(20);

SELECT
    @NewDob = dbo.Fn_NormalizeWord(T24C.DateOfBirth)
FROM dbo.t_NewT24Customers AS NT24C
JOIN dbo.t_T24Customer     AS T24C ON NT24C.CustomerId = T24C.Id
WHERE NT24C.StatusCode = @StatusCode
  AND NT24C.CustomerId = @NewCustomerId;

SET @NewDobSwapped =
    CASE
        WHEN LEN(@NewDob) = 8
        THEN LEFT(@NewDob, 4) + SUBSTRING(@NewDob, 7, 2) + SUBSTRING(@NewDob, 5, 2)
        ELSE NULL
    END;
```

Then use it in your condition:

```sql
AND (
    t.DateOfBirth = @NewDob
    OR t.DateOfBirth = @NewDobSwapped
)
```

---

## Better for consistency (recommended)

You’re already using normalized fields (`Norm_DateOfBirth`, etc.), so it’s usually cleaner to compare against the normalized DOB column too:

```sql
AND (
    t.Norm_DateOfBirth = @NewDob
    OR t.Norm_DateOfBirth = @NewDobSwapped
)
```

That avoids mixing `t.DateOfBirth` and normalized values.

---

## Also update the DOB match flag (important)

Otherwise, swapped DOB rows will be returned, but `Match_DateOfBirth` may still show `0`.

Use:

```sql
CAST(
    CASE
        WHEN t.Norm_DateOfBirth = @NewDob
          OR t.Norm_DateOfBirth = @NewDobSwapped
        THEN 1 ELSE 0
    END AS bit
) AS Match_DateOfBirth,
```

---

## Alternative (even cleaner inside your CTE)

If you prefer not to use variables, you can compute a `SwappedDateOfBirth` column inside the `NC` CTE and reuse `nc.DateOfBirth` / `nc.SwappedDateOfBirth`.

But yes — **using variables at the beginning is totally valid** here, and it’s a good approach for readability.
