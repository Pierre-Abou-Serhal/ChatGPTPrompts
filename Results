This is the request that I am seding to my Loggin API:

{
  "CorolationId": "32bb2752-0fb3-43b5-8bd2-e61758bfa403",
  "AppName": "MoneySend",
  "AppUser": "OSB-USER",
  "LoggingEntity": "OSB",
  "RequestDirection": "Response",
  "RequestType": "Callouts",
  "Operation": "Operation",
  "Path": "Path",
  "URL": "10.0.40.140",
  "ReservedOne": "PostTransfer",
  "ReservedTwo": "",
  "MsgJSON": "{\r\n  \"WSSOGEIBMBGETADDRESSResponse\": {\r\n    \"cards\": [\r\n      {\r\n        \"holder\": {\r\n          \"name\": \"AHHH\",\r\n          \"last_name\": \"asdasdasasd\"\r\n        }\r\n      },\r\n      {\r\n        \"holder\": {\r\n          \"name\": \"BFSG\",\r\n          \"last_name\": \"asdasdasasd\"\r\n        }\r\n      },\r\n      {\r\n        \"holder\": {\r\n          \"name\": \"AHHH\",\r\n          \"last_name\": \"asdasdasasd\"\r\n        }\r\n      },\r\n      {\r\n        \"holder\": {\r\n          \"name\": \"AHHH\",\r\n          \"last_name\": \"asdasdasasd\"\r\n        }\r\n      }\r\n    ],\r\n    \"Status\": { \"successIndicator\": \"Success\" },\r\n    \"ESGBGLOBALBBType\": {\r\n      \"gESGBGLOBALBBDetailType\": {\r\n        \"card\": {\r\n          \"number\": 123456\r\n        },\r\n        \"cards\": [\r\n          {\r\n            \"cvv\": \"test\",\r\n            \"bvv\": \"vvvv\"\r\n          },\r\n          {\r\n            \"cvv\": \"test\",\r\n            \"bvv\": \"vvvv\"\r\n          },\r\n          {\r\n            \"cvv\": \"test\",\r\n            \"bvv\": \"vvvv\"\r\n          }\r\n        ],\r\n        \"mESGBGLOBALBBDetailType\": {\r\n          \"cards\": [\r\n            {\r\n              \"cvv\": \"test\",\r\n              \"bvv\": \"vvvv\"\r\n            },\r\n            {\r\n              \"cvv\": \"test\",\r\n              \"bvv\": \"vvvv\"\r\n            },\r\n            {\r\n              \"cvv\": \"test\",\r\n              \"bvv\": \"vvvv\"\r\n            }\r\n          ],\r\n          \"CustomerID\": \"460784\",\r\n          \"ShortName\": \"PATRICIA YOUSSEF KHADRA\",\r\n          \"Name1\": \"PATRICIA YOUSSEF KHADRA\",\r\n          \"password\": \"600\",\r\n          \"token\": \"CHRISTELLE GERGES\",\r\n          \"SMS\": \"+96176327375\",\r\n          \"GivenName\": \"PATRICIA\",\r\n          \"FamilyName\": \"KHADRA\",\r\n          \"CusCity\": \"16012\",\r\n          \"NATIONALITY\": \"LB\",\r\n          \"NationalityName\": \"Li\",\r\n          \"RESIDENCE\": \"LB\",\r\n          \"Building\": \"118\",\r\n          \"Floor\": \"1\",\r\n          \"Address\": \"118 MUNICIPALITE\",\r\n          \"Street\": \"\",\r\n          \"SGBFinCity\": \"DORA BEYROUTH\",\r\n          \"FinStreet\": \"SGBL\",\r\n          \"CityName\": \"BSALIM - MOH. MONT LIBAN\",\r\n          \"NameResidence\": \"Li\",\r\n          \"SGBFinBLD\": \"SGBL\",\r\n          \"TownCountry\": \"BSALIM\",\r\n          \"COUNTRY\": \"LEBAN\",\r\n          \"Email\": \"PATRICIA.K\",\r\n          \"City\": \"\",\r\n          \"BuildingNo\": \"\",\r\n          \"ApartmentNo\": \"\",\r\n          \"Province\": \"\",\r\n          \"TwnCity\": \"LB\",\r\n          \"FINLOC\": \"16055\",\r\n          \"FinCITY\": \"DORA BEYROUTH\",\r\n          \"Dateofbirth\": \"19850506\",\r\n          \"SGBFINFLRNO\": \"0\",\r\n          \"COMPANYBOOK\": \"LB0010060\",\r\n          \"SGBFINDEPT\": \"\",\r\n          \"FINPROV\": \"\",\r\n          \"card\": {\r\n            \"details\": {\r\n              \"name\": \"TESTTTTTTTTTTT\"\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n",
  "ErrorCode": "",
  "IsError": false
}

And this is my BAL in Asp.Net Core 8

using System.Xml.Linq;
using Microsoft.Extensions.Options;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace BLL;


public class BLL(IOptionsMonitor<AppConfig> optionsMonitor)
{
    public async Task CallProcedureAsync(ParamsCallProcedure callParams)
    {
        var isError = false;

        AppConfig currentOptions = optionsMonitor.CurrentValue;
        List<MaskRule> rules = currentOptions.Masking.Rules;

        if (callParams.MsgXML != "N/A")
        {
            try
            {
                var xdoc = XDocument.Parse(callParams.MsgXML);
                var root = RemoveAllNamespaces(xdoc.Root!);

                // Mask XML
                var maskedXml = XmlMasker.MaskXml(root.ToString(SaveOptions.DisableFormatting), rules);
                callParams.MsgXML = maskedXml;

                // Recompute JSON from masked XML (so JSON matches what was logged)
                var maskedRoot = XDocument.Parse(maskedXml).Root!;
                callParams.MsgJSON = JsonConvert.SerializeXNode(maskedRoot, Formatting.Indented, true);

                // If you also want to apply JSON-only rules (when MsgJSON comes from elsewhere), do:
                callParams.MsgJSON = JsonMasker.MaskJson(callParams.MsgJSON, rules);
            }
            catch (Exception ex)
            {
                isError = true;
                callParams.MsgJSON = ex.Message + "\n" + ex.StackTrace;
            }
        }
        else
        {
            // if MsgJSON is populated independently sometimes:
            callParams.MsgJSON = JsonMasker.MaskJson(callParams.MsgJSON, rules);
        }

        DAL.DAL.AppConfig dalOptions = new()
        {
            ConnectionString = currentOptions.ConnectionString,
            InfoLogSp = currentOptions.InfoLogSp,
            ErrorLogSp = currentOptions.ErrorLogSp,
            InternalLogSp = currentOptions.InternalLogSp,
            FileLogs = currentOptions.FileLogs
        };

        DAL.DAL dal = new(dalOptions);

        if (!isError)
            await dal.DatabaseLogAsync(
                callParams.CorolationId,
                callParams.AppName,
                callParams.AppUser,
                callParams.LoggingEntity,
                callParams.RequestDirection,
                callParams.RequestType,
                callParams.Operation,
                callParams.Path,
                callParams.URL,
                callParams.ReservedOne,
                callParams.ReservedTwo,
                callParams.MsgXML,
                callParams.MsgJSON,
                callParams.ErrorCode,
                callParams.IsError
            );
        else
            await dal.InternalErrorLogAsync(
                callParams.CorolationId,
                callParams.AppName,
                callParams.AppUser,
                callParams.LoggingEntity,
                callParams.RequestDirection,
                callParams.RequestType,
                callParams.Operation,
                callParams.Path,
                callParams.URL,
                callParams.ReservedOne,
                callParams.ReservedTwo,
                callParams.MsgXML,
                callParams.MsgJSON,
                "XML Parsing Error",
                callParams.MsgJSON
            );
    }

    private static XElement RemoveAllNamespaces(XElement element)
    {
        if (element.HasElements)
            return new XElement(element.Name.LocalName,
                element.Elements().Select(RemoveAllNamespaces),
                element.Attributes().Where(a => !a.IsNamespaceDeclaration));

        return new XElement(element.Name.LocalName,
            element.Attributes().Where(a => !a.IsNamespaceDeclaration),
            element.Value);
    }
}


public class AppConfig
{
    public String ConnectionString { get; init; } = string.Empty;
    public String InfoLogSp { get; set; } = "usp_LogInfo";
    public String ErrorLogSp { get; set; } = "usp_LogError";
    public String InternalLogSp { get; set; } = "usp_LogInternal";
    public String FileLogs { get; init; } = "InternalLogFallBack.txt";
    
    public MaskingOptions Masking { get; init; } = new();
}

public class MaskingOptions
{
    public List<MaskRule> Rules { get; init; } = [];
}

public class MaskRule
{
    public String Path { get; init; } = "";
    public String Replacement { get; init; } = "***";
}

/// <summary>
///     Represents the parameters required to execute the logging stored procedure.
/// </summary>
public class ParamsCallProcedure
{
    public required string CorolationId { get; set; }
    public required string AppName { get; set; }
    public required string AppUser { get; set; }
    public required string LoggingEntity { get; set; }
    public string RequestDirection { get; set; } = "N/A";
    public string RequestType { get; set; } = "N/A";
    public string Operation { get; set; } = "N/A";
    public string Path { get; set; } = "N/A";
    public string URL { get; set; } = "N/A";
    public string ReservedOne { get; set; } = "N/A";
    public string ReservedTwo { get; set; } = "N/A";
    public string MsgXML { get; set; } = "N/A";
    public string MsgJSON { get; set; } = "N/A";
    public string? ErrorCode { get; set; } = null;
    public bool IsError { get; set; } = false;
}


#region Mask properties
internal readonly record struct PathToken(string Name, int? Index, bool AllItems);

internal static class MaskPath
{
    public static List<PathToken> Parse(string path)
    {
        // "cards[*].holder.name" -> ["cards[*]", "holder", "name"]
        var parts = path.Split('.', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);

        var tokens = new List<PathToken>(parts.Length);
        foreach (var part in parts)
        {
            // attribute token for XML: "@id" or "card.@id"
            if (part.StartsWith("@"))
            {
                tokens.Add(new PathToken(part, null, false));
                continue;
            }

            var open = part.IndexOf('[');
            if (open < 0)
            {
                tokens.Add(new PathToken(part, null, false));
                continue;
            }

            var close = part.IndexOf(']', open + 1);
            if (close < 0) throw new FormatException($"Invalid path token: {part}");

            var name = part[..open];
            var idxText = part[(open + 1)..close];

            if (idxText == "*" || idxText == "")
            {
                tokens.Add(new PathToken(name, null, true));
            }
            else if (int.TryParse(idxText, out var idx))
            {
                tokens.Add(new PathToken(name, idx, false));
            }
            else
            {
                throw new FormatException($"Invalid array index in token: {part}");
            }
        }

        return tokens;
    }
}

public static class JsonMasker
{
    public static string MaskJson(string json, IEnumerable<MaskRule> rules)
    {
        if (string.IsNullOrWhiteSpace(json) || json == "N/A") return json;

        var root = JToken.Parse(json);

        foreach (var rule in rules)
        {
            ApplyRule(root, rule);
        }

        return root.ToString(Formatting.Indented);
    }

    private static void ApplyRule(JToken root, MaskRule rule)
    {
        if (string.IsNullOrWhiteSpace(rule.Path)) return;

        // If path has no dots/brackets: treat as "mask any property with this name anywhere"
        if (!rule.Path.Contains('.') && !rule.Path.Contains('['))
        {
            MaskAllPropertiesNamed(root, rule.Path, rule.Replacement);
            return;
        }

        var tokens = MaskPath.Parse(rule.Path);
        ApplyTokens(root, tokens, 0, rule.Replacement);
    }

    private static void ApplyTokens(JToken current, List<PathToken> tokens, int i, string replacement)
    {
        if (i >= tokens.Count)
        {
            ReplaceValue(current, replacement);
            return;
        }

        var t = tokens[i];

        if (current is JObject obj)
        {
            if (!obj.TryGetValue(t.Name, out var child))
                return;

            HandleChild(child, tokens, i, replacement, t);
            return;
        }

        if (current is JArray arr)
        {
            // If current is already an array, we traverse items (for paths like "[*].x" if you ever add that)
            foreach (var item in arr)
                ApplyTokens(item, tokens, i, replacement);
        }
    }

    private static void HandleChild(JToken child, List<PathToken> tokens, int i, string replacement, PathToken t)
    {
        if (t.AllItems)
        {
            if (child is JArray a)
                foreach (var item in a) ApplyTokens(item, tokens, i + 1, replacement);
            return;
        }

        if (t.Index is not null)
        {
            if (child is JArray a && t.Index.Value >= 0 && t.Index.Value < a.Count)
                ApplyTokens(a[t.Index.Value]!, tokens, i + 1, replacement);
            return;
        }

        ApplyTokens(child, tokens, i + 1, replacement);
    }

    private static void ReplaceValue(JToken token, string replacement)
    {
        // Replace primitive values; if token is object/array, you can decide policy.
        if (token is JValue v)
            v.Value = replacement;
        else if (token.Parent is JProperty p)
            p.Value = replacement;
    }

    private static void MaskAllPropertiesNamed(JToken root, string propName, string replacement)
    {
        switch (root)
        {
            case JObject obj:
            {
                foreach (var property in obj.Properties().ToList())
                {
                    if (string.Equals(property.Name, propName, StringComparison.OrdinalIgnoreCase))
                    {
                        property.Value = replacement;
                    }
                    else
                    {
                        MaskAllPropertiesNamed(property.Value, propName, replacement);
                    }
                }
                break;
            }

            case JArray arr:
            {
                foreach (var item in arr)
                    MaskAllPropertiesNamed(item, propName, replacement);
                break;
            }

            // JValue or others: nothing to do
        }
    }
}

public static class XmlMasker
{
    public static string MaskXml(string xml, IEnumerable<MaskRule> rules)
    {
        if (string.IsNullOrWhiteSpace(xml) || xml == "N/A") return xml;

        var doc = XDocument.Parse(xml);
        if (doc.Root is null) return xml;

        foreach (var rule in rules)
        {
            ApplyRule(doc.Root, rule);
        }

        return doc.ToString(SaveOptions.DisableFormatting);
    }

    private static void ApplyRule(XElement root, MaskRule rule)
    {
        if (string.IsNullOrWhiteSpace(rule.Path)) return;

        // If path is just "password": mask any element named password anywhere
        if (!rule.Path.Contains('.') && !rule.Path.Contains('[') && !rule.Path.StartsWith("@"))
        {
            foreach (var el in root.DescendantsAndSelf().Where(e =>
                         string.Equals(e.Name.LocalName, rule.Path, StringComparison.OrdinalIgnoreCase)))
            {
                el.Value = rule.Replacement;
            }
            return;
        }

        var tokens = MaskPath.Parse(rule.Path);
        ApplyTokens(root, tokens, 0, rule.Replacement);
    }

    private static void ApplyTokens(XElement current, List<PathToken> tokens, int i, string replacement)
    {
        if (i >= tokens.Count)
        {
            current.Value = replacement;
            return;
        }

        var t = tokens[i];

        // Attribute support: token like "@id"
        if (t.Name.StartsWith("@"))
        {
            var attrName = t.Name[1..];
            var attr = current.Attribute(attrName);
            if (attr is not null) attr.Value = replacement;
            return;
        }

        // find matching children by local name
        var matches = current.Elements().Where(e => string.Equals(e.Name.LocalName, t.Name, StringComparison.OrdinalIgnoreCase)).ToList();
        if (matches.Count == 0) return;

        if (t.AllItems)
        {
            foreach (var m in matches)
                ApplyTokens(m, tokens, i + 1, replacement);
            return;
        }

        if (t.Index is not null)
        {
            var idx = t.Index.Value;
            if (idx >= 0 && idx < matches.Count)
                ApplyTokens(matches[idx], tokens, i + 1, replacement);
            return;
        }

        // normal element step (if multiple matches, apply to all)
        foreach (var m in matches)
            ApplyTokens(m, tokens, i + 1, replacement);
    }
}

#endregion

This is my appsettings:
{
  "Urls": "https://localhost:7217",
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "AppConfig": {
    "ConnectionString": "Data Source=DEV;Initial Catalog=Alterna.Logger;User ID=admin;Password=admin;TrustServerCertificate=True;",
    "InfoLogSP": "usp_LogInfo",
    "ErrorLogSP": "usp_LogError",
    "InternalLogSP": "usp_LogInternal",
    "FileLogs": "C:\\Logs\\InternalLogFallBack.txt",
    "Masking": {
      "Rules": [
        { "Path": "card.details.name", "Replacement": "***" },
        { "Path": "card.number", "Replacement": "****MASKED****" },
        { "Path": "cards[*].cvv", "Replacement": "***" },
        { "Path": "cards[*].holder.name", "Replacement": "***" },

        { "Path": "password", "Replacement": "***" },
        { "Path": "token", "Replacement": "***" }
      ]
    }
  }
}

When trying to call this API:
    public async Task<IActionResult> LogData([FromBody] ParamsCallProcedure callProcedure)
    {
        if (!ModelState.IsValid) return BadRequest(ModelState);

        try
        {
            await _bll.CallProcedureAsync(callProcedure);
            // Altered response to aid in debugging
            return Ok(new { message = "Log entry created successfully.", dataReceived = callProcedure });
        }
        catch (Exception ex)
        {
            // Log the exception details as needed (e.g., to a file or monitoring system)
            return StatusCode(500, new
            {
                error = $"An unexpected exception occurred.\n{ex.Message}",
                // Including additional debug information
                exception = ex.ToString()
            });
        }
    }

only yhe properties: "password" and "token" are getting masked

Why ?
