public static class XmlMasker
{
    public static string MaskXml(string xml, IEnumerable<MaskRule> rules)
    {
        if (string.IsNullOrWhiteSpace(xml) || xml == "N/A") return xml;

        var doc = XDocument.Parse(xml);
        if (doc.Root is null) return xml;

        foreach (var rule in rules)
        {
            ApplyRule(doc.Root, rule);
        }

        return doc.ToString(SaveOptions.DisableFormatting);
    }

    private static void ApplyRule(XElement root, MaskRule rule)
    {
        if (string.IsNullOrWhiteSpace(rule.Path)) return;

        // Optional: allow "**." to mean "match anywhere" for XML too
        var path = rule.Path;
        if (path.StartsWith("**.", StringComparison.Ordinal))
            path = path[3..];

        // If path is just "password": mask any element named password anywhere
        if (!path.Contains('.') && !path.Contains('[') && !path.StartsWith("@"))
        {
            foreach (var el in root.DescendantsAndSelf().Where(e =>
                         string.Equals(e.Name.LocalName, path, StringComparison.OrdinalIgnoreCase)))
            {
                el.Value = ApplyRuleToText(el.Value, rule);
            }
            return;
        }

        var tokens = MaskPath.Parse(path);

        // If the original rule started with "**.", try applying from every node
        if (rule.Path.StartsWith("**.", StringComparison.Ordinal))
        {
            foreach (var start in root.DescendantsAndSelf())
                ApplyTokens(start, tokens, 0, rule);

            return;
        }

        ApplyTokens(root, tokens, 0, rule);
    }

    private static void ApplyTokens(XElement current, List<PathToken> tokens, int i, MaskRule rule)
    {
        if (i >= tokens.Count)
        {
            current.Value = ApplyRuleToText(current.Value, rule);
            return;
        }

        var t = tokens[i];

        // Attribute support: token like "@id"
        if (t.Name.StartsWith("@"))
        {
            var attrName = t.Name[1..];
            var attr = current.Attribute(attrName);
            if (attr is not null)
                attr.Value = ApplyRuleToText(attr.Value, rule);
            return;
        }

        // find matching children by local name
        var matches = current.Elements()
            .Where(e => string.Equals(e.Name.LocalName, t.Name, StringComparison.OrdinalIgnoreCase))
            .ToList();

        if (matches.Count == 0) return;

        if (t.AllItems)
        {
            foreach (var m in matches)
                ApplyTokens(m, tokens, i + 1, rule);
            return;
        }

        if (t.Index is not null)
        {
            var idx = t.Index.Value;
            if (idx >= 0 && idx < matches.Count)
                ApplyTokens(matches[idx], tokens, i + 1, rule);
            return;
        }

        // normal element step (if multiple matches, apply to all)
        foreach (var m in matches)
            ApplyTokens(m, tokens, i + 1, rule);
    }

    private static string MaskKeepLast(string input, int keepLast, char maskChar)
    {
        if (string.IsNullOrEmpty(input)) return input;

        if (keepLast <= 0)
            return new string(maskChar, input.Length);

        if (input.Length <= keepLast)
            return input;

        return new string(maskChar, input.Length - keepLast) + input[^keepLast..];
    }

    private static string ApplyRuleToText(string? currentText, MaskRule rule)
    {
        if (currentText is null) return rule.Replacement;

        if (rule.KeepLast is > 0)
            return MaskKeepLast(currentText, (int)rule.KeepLast.Value, rule.MaskChar);

        return rule.Replacement;
    }
}
