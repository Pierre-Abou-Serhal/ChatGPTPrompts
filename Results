using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;

public static class DuplicateCustomerGrader
{
    // Hard-coded weights (later you can load them from DB)
    private const decimal W_DateOfBirth   = 30m;
    private const decimal W_GivenNames    = 10m;
    private const decimal W_FamilyName    = 10m;
    private const decimal W_FatherName    = 10m;
    private const decimal W_MoFirstName   = 10m;
    private const decimal W_BirthRegister = 10m;
    private const decimal W_BirthRegNo    = 10m;
    private const decimal W_Gender        = 10m;

    /// <summary>
    /// Grades a single DTO in-place (fills Match_* and Mark_*).
    /// </summary>
    public static void Grade(DuplicateCustomerDto dto)
    {
        if (dto == null) throw new ArgumentNullException(nameof(dto));

        // Exact fields
        dto.Match_DateOfBirth = ExactDateMatch(dto.New_DateOfBirth, dto.Db_DateOfBirth);
        dto.Mark_DateOfBirth  = dto.Match_DateOfBirth ? W_DateOfBirth : 0m;

        dto.Match_BirthRegister = ExactTextMatch(dto.New_BirthRegister, dto.Db_BirthRegister);
        dto.Mark_BirthRegister  = dto.Match_BirthRegister ? W_BirthRegister : 0m;

        dto.Match_BirthRegNo = ExactTextMatch(dto.New_BirthRegNo, dto.Db_BirthRegNo);
        dto.Mark_BirthRegNo  = dto.Match_BirthRegNo ? W_BirthRegNo : 0m;

        dto.Match_Gender = ExactTextMatch(dto.New_Gender, dto.Db_Gender);
        dto.Mark_Gender  = dto.Match_Gender ? W_Gender : 0m;

        // Fuzzy fields (0..weight)
        dto.Mark_GivenNames  = FuzzyMark(dto.New_GivenNames,  dto.Db_GivenNames,  W_GivenNames,  out bool mGiven);
        dto.Match_GivenNames = mGiven;

        dto.Mark_FamilyName  = FuzzyMark(dto.New_FamilyName,  dto.Db_FamilyName,  W_FamilyName,  out bool mFamily);
        dto.Match_FamilyName = mFamily;

        dto.Mark_FatherName  = FuzzyMark(dto.New_FatherName,  dto.Db_FatherName,  W_FatherName,  out bool mFather);
        dto.Match_FatherName = mFather;

        dto.Mark_MoFirstName  = FuzzyMark(dto.New_MoFirstName, dto.Db_MoFirstName, W_MoFirstName, out bool mMo);
        dto.Match_MoFirstName = mMo;
    }

    /// <summary>
    /// Grades a list in-place.
    /// </summary>
    public static void GradeAll(IEnumerable<DuplicateCustomerDto> items)
    {
        if (items == null) return;
        foreach (var dto in items) Grade(dto);
    }

    // -----------------------
    // Exact matching helpers
    // -----------------------

    private static bool ExactTextMatch(string a, string b)
    {
        // If either is missing, return false to avoid awarding marks for incomplete data.
        if (string.IsNullOrWhiteSpace(a) || string.IsNullOrWhiteSpace(b))
            return false;

        return string.Equals(NormalizeText(a), NormalizeText(b), StringComparison.Ordinal);
    }

    private static bool ExactDateMatch(string a, string b)
    {
        if (string.IsNullOrWhiteSpace(a) || string.IsNullOrWhiteSpace(b))
            return false;

        // Try parsing both; if parsed, compare Date
        if (TryParseDate(a, out var da) && TryParseDate(b, out var db))
            return da.Date == db.Date;

        // Fallback to normalized text compare if parsing fails
        return string.Equals(NormalizeText(a), NormalizeText(b), StringComparison.Ordinal);
    }

    private static bool TryParseDate(string s, out DateTime dt)
    {
        // Add/adjust patterns to match your input formats
        var formats = new[]
        {
            "yyyy-MM-dd",
            "dd/MM/yyyy",
            "MM/dd/yyyy",
            "yyyyMMdd",
            "dd-MM-yyyy",
            "MM-dd-yyyy"
        };

        return DateTime.TryParseExact(
                   s.Trim(),
                   formats,
                   CultureInfo.InvariantCulture,
                   DateTimeStyles.None,
                   out dt)
               || DateTime.TryParse(s, CultureInfo.InvariantCulture, DateTimeStyles.None, out dt);
    }

    // -----------------------
    // Fuzzy matching helpers
    // -----------------------

    /// <summary>
    /// Returns mark 0..weight based on Levenshtein similarity (0..1).
    /// Also outputs a boolean Match based on a threshold.
    /// </summary>
    private static decimal FuzzyMark(string a, string b, decimal weight, out bool isMatch)
    {
        if (string.IsNullOrWhiteSpace(a) || string.IsNullOrWhiteSpace(b))
        {
            isMatch = false;
            return 0m;
        }

        var na = NormalizeText(a);
        var nb = NormalizeText(b);

        var sim = SimilarityLevenshtein(na, nb); // 0..1

        // Define what "Match_*" means for fuzzy fields.
        // Example: consider it a match if >= 0.85 similarity.
        isMatch = sim >= 0.85;

        // Mark is proportional to similarity, capped to [0..weight]
        var mark = weight * (decimal)sim;
        return ClampDecimal(mark, 0m, weight);
    }

    private static double SimilarityLevenshtein(string a, string b)
    {
        if (a == b) return 1.0;
        if (a.Length == 0 || b.Length == 0) return 0.0;

        int dist = LevenshteinDistance(a, b);
        int maxLen = Math.Max(a.Length, b.Length);

        // similarity = 1 - normalized distance
        return 1.0 - (double)dist / maxLen;
    }

    // Classic DP Levenshtein (works fine for short strings like names)
    private static int LevenshteinDistance(string s, string t)
    {
        int n = s.Length, m = t.Length;
        var d = new int[n + 1, m + 1];

        for (int i = 0; i <= n; i++) d[i, 0] = i;
        for (int j = 0; j <= m; j++) d[0, j] = j;

        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= m; j++)
            {
                int cost = (s[i - 1] == t[j - 1]) ? 0 : 1;

                d[i, j] = Math.Min(
                    Math.Min(d[i - 1, j] + 1, d[i, j - 1] + 1),
                    d[i - 1, j - 1] + cost);
            }
        }

        return d[n, m];
    }

    // -----------------------
    // Normalization helpers
    // -----------------------

    private static string NormalizeText(string input)
    {
        if (input == null) return string.Empty;

        // 1) Trim + uppercase
        var s = input.Trim().ToUpperInvariant();

        // 2) Remove diacritics (Ã© -> E, etc.)
        s = RemoveDiacritics(s);

        // 3) Keep letters/digits/spaces only, collapse spaces
        var sb = new StringBuilder(s.Length);
        bool prevSpace = false;

        foreach (char c in s)
        {
            if (char.IsLetterOrDigit(c))
            {
                sb.Append(c);
                prevSpace = false;
            }
            else if (char.IsWhiteSpace(c))
            {
                if (!prevSpace)
                {
                    sb.Append(' ');
                    prevSpace = true;
                }
            }
            // ignore punctuation/symbols
        }

        return sb.ToString().Trim();
    }

    private static string RemoveDiacritics(string text)
    {
        var normalized = text.Normalize(NormalizationForm.FormD);
        var sb = new StringBuilder(normalized.Length);

        foreach (var c in normalized)
        {
            var uc = CharUnicodeInfo.GetUnicodeCategory(c);
            if (uc != UnicodeCategory.NonSpacingMark)
                sb.Append(c);
        }

        return sb.ToString().Normalize(NormalizationForm.FormC);
    }

    private static decimal ClampDecimal(decimal value, decimal min, decimal max)
        => value < min ? min : (value > max ? max : value);
}
