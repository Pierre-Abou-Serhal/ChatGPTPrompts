```csharp
private static void ApplyTokens(XElement current, List<PathToken> tokens, int i, MaskRule rule)
{
    if (i >= tokens.Count)
    {
        // We reached the target element
        current.Value = ApplyRuleToText(current.Value, rule);
        return;
    }

    var t = tokens[i];

    // 1) Attribute support: token like "@id"
    if (t.Name.StartsWith("@", StringComparison.Ordinal))
    {
        var attrName = t.Name[1..];

        // Match attribute by LocalName (namespace-safe)
        var attr = current.Attributes()
            .FirstOrDefault(a => string.Equals(a.Name.LocalName, attrName, StringComparison.OrdinalIgnoreCase));

        if (attr is not null)
            attr.Value = ApplyRuleToText(attr.Value, rule);

        return;
    }

    // 2) âœ… Self-match support:
    // If the current element itself matches this token, consume it and continue.
    // This is required for paths like "ReissueCard.ContractIdentifier" when ReissueCard is the XML root.
    if (string.Equals(current.Name.LocalName, t.Name, StringComparison.OrdinalIgnoreCase))
    {
        ApplyTokens(current, tokens, i + 1, rule);
        return;
    }

    // 3) Find matching child elements by LocalName (namespace-safe)
    var matches = current.Elements()
        .Where(e => string.Equals(e.Name.LocalName, t.Name, StringComparison.OrdinalIgnoreCase))
        .ToList();

    if (matches.Count == 0) return;

    // 4) Handle [*] (all items)
    if (t.AllItems)
    {
        foreach (var m in matches)
            ApplyTokens(m, tokens, i + 1, rule);
        return;
    }

    // 5) Handle [index]
    if (t.Index is not null)
    {
        var idx = t.Index.Value;
        if (idx >= 0 && idx < matches.Count)
            ApplyTokens(matches[idx], tokens, i + 1, rule);
        return;
    }

    // 6) Normal step (apply to all matches)
    foreach (var m in matches)
        ApplyTokens(m, tokens, i + 1, rule);
}
```
