You can do this cleanly if you treat it as **“transform before log”** with **one masking engine**, and two adapters:

* **XML → mask via XElement**
* **JSON → mask via JToken**
* **Single config model** that supports:

  * exact field names (ex: `name`)
  * **paths** (ex: `card.details.name`)
  * **arrays** (ex: `cards[*].number`, `cards[].number`, `cards[0].number`)
  * and optionally **XML attribute masking** (ex: `card.@number`)

Below is a solid pattern that works well in .NET apps and keeps your BLL readable.

---

## 1) appsettings.json design

Use a list of rules (easier to extend than a dictionary):

```json
{
  "AppConfig": {
    "ConnectionString": "...",
    "InfoLogSp": "usp_LogInfo",
    "ErrorLogSp": "usp_LogError",
    "InternalLogSp": "usp_LogInternal",
    "FileLogs": "InternalLogFallBack.txt",

    "Masking": {
      "Rules": [
        { "Path": "card.details.name", "Replacement": "***" },
        { "Path": "card.number", "Replacement": "****MASKED****" },
        { "Path": "cards[*].cvv", "Replacement": "***" },
        { "Path": "cards[*].holder.name", "Replacement": "***" },

        { "Path": "password", "Replacement": "***" },
        { "Path": "token", "Replacement": "***" }
      ]
    }
  }
}
```

Notes:

* Paths are **dot separated**.
* Arrays: `[*]` means “all items”.
* If you put `password` (no dots), it matches **any element/property with that name anywhere** (handy).

---

## 2) Config classes

```csharp
public class AppConfig
{
    public string ConnectionString { get; init; } = string.Empty;
    public string InfoLogSp { get; set; } = "usp_LogInfo";
    public string ErrorLogSp { get; set; } = "usp_LogError";
    public string InternalLogSp { get; set; } = "usp_LogInternal";
    public string FileLogs { get; init; } = "InternalLogFallBack.txt";

    public MaskingOptions Masking { get; init; } = new();
}

public class MaskingOptions
{
    public List<MaskRule> Rules { get; init; } = new();
}

public class MaskRule
{
    public string Path { get; init; } = "";        // e.g. "card.details.name" or "cards[*].cvv"
    public string Replacement { get; init; } = "***";
}
```

---

## 3) Where to call it in your BLL

Right before you call DAL:

* parse XML (if any) and create JSON (you already do)
* **mask both strings**
* then log masked versions

Important: mask *after* you “RemoveAllNamespaces” if you want stable XML paths.

---

## 4) Masking engine (JSON + XML)

### 4.1 A small path parser you can reuse

Supports tokens: `prop`, `prop[*]`, `prop[0]`, and attribute `@attr` for XML if you want.

```csharp
internal readonly record struct PathToken(string Name, int? Index, bool AllItems);

internal static class MaskPath
{
    public static List<PathToken> Parse(string path)
    {
        // "cards[*].holder.name" -> ["cards[*]", "holder", "name"]
        var parts = path.Split('.', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);

        var tokens = new List<PathToken>(parts.Length);
        foreach (var part in parts)
        {
            // attribute token for XML: "@id" or "card.@id"
            if (part.StartsWith("@"))
            {
                tokens.Add(new PathToken(part, null, false));
                continue;
            }

            var open = part.IndexOf('[');
            if (open < 0)
            {
                tokens.Add(new PathToken(part, null, false));
                continue;
            }

            var close = part.IndexOf(']', open + 1);
            if (close < 0) throw new FormatException($"Invalid path token: {part}");

            var name = part[..open];
            var idxText = part[(open + 1)..close];

            if (idxText == "*" || idxText == "")
            {
                tokens.Add(new PathToken(name, null, true));
            }
            else if (int.TryParse(idxText, out var idx))
            {
                tokens.Add(new PathToken(name, idx, false));
            }
            else
            {
                throw new FormatException($"Invalid array index in token: {part}");
            }
        }

        return tokens;
    }
}
```

---

### 4.2 JSON masking (Newtonsoft)

```csharp
using Newtonsoft.Json.Linq;

public static class JsonMasker
{
    public static string MaskJson(string json, IEnumerable<MaskRule> rules)
    {
        if (string.IsNullOrWhiteSpace(json) || json == "N/A") return json;

        var root = JToken.Parse(json);

        foreach (var rule in rules)
        {
            ApplyRule(root, rule);
        }

        return root.ToString(Newtonsoft.Json.Formatting.Indented);
    }

    private static void ApplyRule(JToken root, MaskRule rule)
    {
        if (string.IsNullOrWhiteSpace(rule.Path)) return;

        // If path has no dots/brackets: treat as "mask any property with this name anywhere"
        if (!rule.Path.Contains('.') && !rule.Path.Contains('['))
        {
            MaskAllPropertiesNamed(root, rule.Path, rule.Replacement);
            return;
        }

        var tokens = MaskPath.Parse(rule.Path);
        ApplyTokens(root, tokens, 0, rule.Replacement);
    }

    private static void ApplyTokens(JToken current, List<PathToken> tokens, int i, string replacement)
    {
        if (i >= tokens.Count)
        {
            ReplaceValue(current, replacement);
            return;
        }

        var t = tokens[i];

        if (current is JObject obj)
        {
            if (!obj.TryGetValue(t.Name, out var child))
                return;

            HandleChild(child, tokens, i, replacement, t);
            return;
        }

        if (current is JArray arr)
        {
            // If current is already an array, we traverse items (for paths like "[*].x" if you ever add that)
            foreach (var item in arr)
                ApplyTokens(item, tokens, i, replacement);
        }
    }

    private static void HandleChild(JToken child, List<PathToken> tokens, int i, string replacement, PathToken t)
    {
        if (t.AllItems)
        {
            if (child is JArray a)
                foreach (var item in a) ApplyTokens(item, tokens, i + 1, replacement);
            return;
        }

        if (t.Index is not null)
        {
            if (child is JArray a && t.Index.Value >= 0 && t.Index.Value < a.Count)
                ApplyTokens(a[t.Index.Value]!, tokens, i + 1, replacement);
            return;
        }

        ApplyTokens(child, tokens, i + 1, replacement);
    }

    private static void ReplaceValue(JToken token, string replacement)
    {
        // Replace primitive values; if token is object/array, you can decide policy.
        if (token is JValue v)
            v.Value = replacement;
        else if (token.Parent is JProperty p)
            p.Value = replacement;
    }

    private static void MaskAllPropertiesNamed(JToken root, string propName, string replacement)
    {
        foreach (var prop in root.Descendants().OfType<JProperty>())
        {
            if (string.Equals(prop.Name, propName, StringComparison.OrdinalIgnoreCase))
                prop.Value = replacement;
        }
    }
}
```

---

### 4.3 XML masking (XElement)

This is the XML equivalent: walk elements according to tokens, and replace the text value of the final element. (Optional: support `@attr` tokens.)

```csharp
using System.Xml.Linq;

public static class XmlMasker
{
    public static string MaskXml(string xml, IEnumerable<MaskRule> rules)
    {
        if (string.IsNullOrWhiteSpace(xml) || xml == "N/A") return xml;

        var doc = XDocument.Parse(xml);
        if (doc.Root is null) return xml;

        foreach (var rule in rules)
        {
            ApplyRule(doc.Root, rule);
        }

        return doc.ToString(SaveOptions.DisableFormatting);
    }

    private static void ApplyRule(XElement root, MaskRule rule)
    {
        if (string.IsNullOrWhiteSpace(rule.Path)) return;

        // If path is just "password": mask any element named password anywhere
        if (!rule.Path.Contains('.') && !rule.Path.Contains('[') && !rule.Path.StartsWith("@"))
        {
            foreach (var el in root.DescendantsAndSelf().Where(e =>
                         string.Equals(e.Name.LocalName, rule.Path, StringComparison.OrdinalIgnoreCase)))
            {
                el.Value = rule.Replacement;
            }
            return;
        }

        var tokens = MaskPath.Parse(rule.Path);
        ApplyTokens(root, tokens, 0, rule.Replacement);
    }

    private static void ApplyTokens(XElement current, List<PathToken> tokens, int i, string replacement)
    {
        if (i >= tokens.Count)
        {
            current.Value = replacement;
            return;
        }

        var t = tokens[i];

        // Attribute support: token like "@id"
        if (t.Name.StartsWith("@"))
        {
            var attrName = t.Name[1..];
            var attr = current.Attribute(attrName);
            if (attr is not null) attr.Value = replacement;
            return;
        }

        // find matching children by local name
        var matches = current.Elements().Where(e => string.Equals(e.Name.LocalName, t.Name, StringComparison.OrdinalIgnoreCase)).ToList();
        if (matches.Count == 0) return;

        if (t.AllItems)
        {
            foreach (var m in matches)
                ApplyTokens(m, tokens, i + 1, replacement);
            return;
        }

        if (t.Index is not null)
        {
            var idx = t.Index.Value;
            if (idx >= 0 && idx < matches.Count)
                ApplyTokens(matches[idx], tokens, i + 1, replacement);
            return;
        }

        // normal element step (if multiple matches, apply to all)
        foreach (var m in matches)
            ApplyTokens(m, tokens, i + 1, replacement);
    }
}
```

**How XML arrays are handled:** repeated elements of the same name are treated like an array:

* `cards[*].cvv` masks `<cards> ... </cards>` items if your XML structure repeats `<cards>` elements.
* `cards[0].cvv` masks only the first.

This is the best general mapping without forcing XML into JSON or vice versa.

---

## 5) Wire it into your existing code

Inside `CallProcedureAsync`, after you compute `MsgJSON`:

```csharp
var currentOptions = optionsMonitor.CurrentValue;
var rules = currentOptions.Masking?.Rules ?? [];

if (callParams.MsgXML != "N/A")
{
    try
    {
        var xdoc = XDocument.Parse(callParams.MsgXML);
        var root = RemoveAllNamespaces(xdoc.Root!);

        // Mask XML (use root.ToString to keep it aligned with removed namespaces)
        var maskedXml = XmlMasker.MaskXml(root.ToString(SaveOptions.DisableFormatting), rules);
        callParams.MsgXML = maskedXml;

        // Recompute JSON from masked XML (so JSON matches what was logged)
        var maskedRoot = XDocument.Parse(maskedXml).Root!;
        callParams.MsgJSON = JsonConvert.SerializeXNode(maskedRoot, Formatting.Indented, true);

        // If you also want to apply JSON-only rules (when MsgJSON comes from elsewhere), do:
        callParams.MsgJSON = JsonMasker.MaskJson(callParams.MsgJSON, rules);
    }
    catch (Exception ex)
    {
        isError = true;
        callParams.MsgJSON = ex.Message + "\n" + ex.StackTrace;
    }
}
else
{
    // if MsgJSON is populated independently sometimes:
    callParams.MsgJSON = JsonMasker.MaskJson(callParams.MsgJSON, rules);
}
```

### Why I recommend masking XML first then generating JSON

Because your JSON is derived from XML. If you mask both independently you can end up with “XML masked one way, JSON masked another way”. Mask XML first → JSON automatically consistent.

---

## 6) “Best way” notes (practical)

* **Don’t store the raw unmasked payload anywhere** unless you truly need it (and then restrict access hard).
* Consider adding a “default replacement” (`"***"`) and per-rule override (you already have that).
* If you have performance concerns (big payloads), parse paths once:

  * at startup / on options change (`IOptionsMonitor.OnChange`)
  * compile `rule.Path` → `List<PathToken>` and store.

---

## 7) Edge cases you’ll want to decide now

1. **Masking objects/arrays:** if a rule points to an object (`card.details`), should you:

* replace whole object with `"***"`?
* or traverse and mask leaf values only?
  Right now the JSON code replaces only values or property targets. That’s usually what you want.

2. **Case sensitivity:** I used `OrdinalIgnoreCase` for convenience. If you want strict matching, switch to `Ordinal`.

3. **Namespaces:** You remove namespaces already. Good. That makes XML paths stable.

---

If you paste one example of your real XML + the JSON shape you expect, I can adapt the path rules so `card.details.name` matches **exactly** how your XML is structured (because sometimes XML has wrapper nodes like `<card><details><name>..`).
