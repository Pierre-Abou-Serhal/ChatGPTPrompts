Use **YAML templates**. That’s the best way to reuse the same CI/CD logic across many .NET Core Web API projects.

## Recommended structure

Create a separate repo (or a folder in one repo) for templates, for example:

* `DevOps.Templates`

  * `templates/build-dotnet-webapi.yml`
  * `templates/deploy-iis.yml`
  * `templates/pipeline-dotnet-iis.yml` (optional combined template)

Then each project pipeline becomes very small and only passes parameters.

---

## What to reuse

Split your reusable parts into templates:

### 1) Build template

Reusable for all .NET projects:

* restore
* build
* publish
* zip
* publish build artifact (on-prem: `PublishBuildArtifacts@1`)

### 2) Deploy IIS template

Reusable for all IIS deployments:

* download artifact
* extract
* file transform
* stop website/app pool
* copy files
* start website/app pool

### 3) Optional full pipeline template

If all projects follow the exact same branch strategy (`sit`, `uat`, `master`), you can make one template that includes:

* Build stage
* Deploy_SIT
* Deploy_UAT
* Deploy_PROD

Then per project you only pass names/paths/pools/variable groups.

---

# Example reusable templates

## A) Build template (`templates/build-dotnet-webapi.yml`)

```yml
parameters:
- name: buildPool
  type: string
- name: buildAgentName
  type: string
- name: solutionOrProject
  type: string
  default: '**/*.csproj'
- name: buildConfiguration
  type: string
  default: 'Release'
- name: nugetConfigPath
  type: string
  default: 'nuget.config'
- name: publishProject
  type: string
- name: zipName
  type: string
  default: 'WebApp.zip'

jobs:
- job: BuildJob
  displayName: Build (.NET)
  pool:
    name: ${{ parameters.buildPool }}
    demands:
    - Agent.Name -equals ${{ parameters.buildAgentName }}

  steps:
  - checkout: self
    clean: true

  - task: DotNetCoreCLI@2
    displayName: Restore
    inputs:
      command: restore
      projects: ${{ parameters.solutionOrProject }}
      feedsToUse: 'config'
      nugetConfigPath: ${{ parameters.nugetConfigPath }}

  - task: DotNetCoreCLI@2
    displayName: Build
    inputs:
      command: build
      projects: ${{ parameters.solutionOrProject }}
      arguments: '--configuration ${{ parameters.buildConfiguration }} --no-restore'

  - task: DotNetCoreCLI@2
    displayName: Publish
    inputs:
      command: publish
      projects: ${{ parameters.publishProject }}
      arguments: '--configuration ${{ parameters.buildConfiguration }} --output $(Build.ArtifactStagingDirectory)\publish --no-restore'
      zipAfterPublish: false

  - task: ArchiveFiles@2
    displayName: Zip publish output
    inputs:
      rootFolderOrFile: '$(Build.ArtifactStagingDirectory)\publish'
      includeRootFolder: false
      archiveType: zip
      archiveFile: '$(Build.ArtifactStagingDirectory)\${{ parameters.zipName }}'
      replaceExistingArchive: true

  - task: PublishBuildArtifacts@1
    displayName: Publish Build Artifact
    inputs:
      PathtoPublish: '$(Build.ArtifactStagingDirectory)\${{ parameters.zipName }}'
      ArtifactName: 'drop'
      publishLocation: 'Container'
```

---

## B) IIS deploy template (`templates/deploy-iis.yml`)

```yml
parameters:
- name: environmentName
  type: string
- name: stageName
  type: string
- name: stageDisplayName
  type: string
- name: branchRef
  type: string
- name: deployPool
  type: string
- name: deployAgentName
  type: string
- name: variableGroup
  type: string
- name: zipName
  type: string
- name: siteName
  type: string
- name: appPoolName
  type: string
- name: iisTargetPath
  type: string

stages:
- stage: ${{ parameters.stageName }}
  displayName: ${{ parameters.stageDisplayName }}
  dependsOn: Build
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], '${{ parameters.branchRef }}'))
  jobs:
  - deployment: DeployJob
    displayName: 'Deploy to ${{ parameters.environmentName }}'
    environment: ${{ parameters.environmentName }}
    pool:
      name: ${{ parameters.deployPool }}
      demands:
      - Agent.Name -equals ${{ parameters.deployAgentName }}
    variables:
    - group: ${{ parameters.variableGroup }}

    strategy:
      runOnce:
        deploy:
          steps:
          - task: DownloadBuildArtifacts@0
            displayName: Download Build Artifact
            inputs:
              buildType: current
              downloadType: single
              artifactName: drop
              downloadPath: '$(Pipeline.Workspace)'

          - task: ExtractFiles@1
            displayName: Extract artifact
            inputs:
              archiveFilePatterns: '$(Pipeline.Workspace)\drop\${{ parameters.zipName }}'
              destinationFolder: '$(Pipeline.Workspace)\extracted'
              cleanDestinationFolder: true

          - task: FileTransform@1
            displayName: JSON substitution (appsettings.json)
            inputs:
              folderPath: '$(Pipeline.Workspace)\extracted'
              fileType: 'json'
              targetFiles: '**/appsettings.json'

          - powershell: |
              Import-Module WebAdministration

              $siteName = "${{ parameters.siteName }}"
              $appPool  = "${{ parameters.appPoolName }}"

              $site = Get-Website -Name $siteName
              if ($site.State -ne "Stopped") { Stop-Website -Name $siteName }

              $poolState = (Get-WebAppPoolState -Name $appPool).Value
              if ($poolState -ne "Stopped") { Stop-WebAppPool -Name $appPool }

              Start-Sleep -Seconds 2
            displayName: 'Stop Website + App Pool'

          - task: CopyFiles@2
            displayName: Copy files
            inputs:
              SourceFolder: '$(Pipeline.Workspace)\extracted'
              Contents: '**'
              TargetFolder: '${{ parameters.iisTargetPath }}'
              OverWrite: true

          - powershell: |
              Import-Module WebAdministration

              $siteName = "${{ parameters.siteName }}"
              $appPool  = "${{ parameters.appPoolName }}"

              $poolState = (Get-WebAppPoolState -Name $appPool).Value
              if ($poolState -ne "Started") { Start-WebAppPool -Name $appPool }

              $siteState = (Get-Website -Name $siteName).State
              if ($siteState -ne "Started") { Start-Website -Name $siteName }
            displayName: 'Start Website + App Pool'
```

---

# How each project pipeline will look (small and clean)

## Project pipeline (`azure-pipelines.yml` inside each app repo)

```yml
resources:
  repositories:
  - repository: templates
    type: git
    name: DEV/DevOps.Templates   # ProjectName/RepoName in Azure DevOps Server
    ref: refs/heads/master

trigger:
  branches:
    include:
    - sit
    - uat
    - master

variables:
  buildConfiguration: 'Release'

stages:
- stage: Build
  displayName: Build & Publish Artifact
  jobs:
  - template: templates/build-dotnet-webapi.yml@templates
    parameters:
      buildPool: 'Build Pool'
      buildAgentName: 'UAT-ALTERNA-DK1'
      solutionOrProject: '**/*.csproj'
      nugetConfigPath: 'nuget.config'
      publishProject: 'Alterna-DataExport/Alterna-DataExport/Alterna-DataExport.csproj'
      buildConfiguration: 'Release'
      zipName: 'Alterna-DataExport.zip'

- template: templates/deploy-iis.yml@templates
  parameters:
    environmentName: 'SIT'
    stageName: 'Deploy_SIT'
    stageDisplayName: 'Deploy to SIT'
    branchRef: 'refs/heads/sit'
    deployPool: 'Build Pool'
    deployAgentName: 'SIT-ALTERNA-BN1'
    variableGroup: 'SIT_VARIABLE_GROUP'
    zipName: 'Alterna-DataExport.zip'
    siteName: 'AlternaDataExportServiceAzureDevOps'
    appPoolName: 'AlternaDataExportServiceAzureDevOps'
    iisTargetPath: 'C:\inetpub\wwwroot\AlternaDataExportService-AzureDevOps-BN1'

# Add same template again for UAT
# Add same template again for PROD
```

---

## Why this is the best approach

### ✅ Benefits

* Reuse the same proven logic for all projects
* Fix once in template → all pipelines benefit
* Less copy/paste mistakes
* Easier onboarding for new projects

### ✅ What changes per project

Only parameters:

* project path
* zip name
* IIS path
* app pool/site name
* variable group
* agent name/pool

---

## Extra best practices for scale

### 1) Standardize naming

If all projects follow consistent naming:

* `VG-SIT-{AppName}`
* `VG-UAT-{AppName}`
* `VG-PROD-{AppName}`
* IIS site/app pool names follow a pattern

Then templates become even cleaner.

### 2) Version your templates

Keep templates in a dedicated repo and use tags/branches if needed:

* `ref: refs/heads/master`
  or
* `ref: refs/tags/v1.0`

### 3) Add a shared “pre-deploy checks” template later

For example:

* verify folder exists
* verify website/app pool exists
* verify agent identity
* optional backup

---

## One important note for Azure DevOps Server (on-prem)

Use:

* `PublishBuildArtifacts@1` / `DownloadBuildArtifacts@0`
  and avoid:
* `publish:` / `download:` shortcuts (Pipeline Artifacts)

You already discovered this — keep it in your templates too.

---

If you want, I can generate a **full template set** for your exact setup (Build + SIT/UAT/PROD deploy with approvals) and a **sample pipeline for a second project** so you can copy the pattern immediately.
