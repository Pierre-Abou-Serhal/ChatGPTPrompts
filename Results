Because your “path rules” (the ones with dots / arrays) are being applied **from the JSON root**, but in your payload the fields you want are **not at the root**.

Your JSON starts like this:

```json
{
  "WSSOGEIBMBGETADDRESSResponse": {
    "cards": [ ... ],
    "ESGBGLOBALBBType": {
      "gESGBGLOBALBBDetailType": {
        "card": { "number": 123456 },
        "cards": [ { "cvv": "test" } ],
        "mESGBGLOBALBBDetailType": {
          "card": { "details": { "name": "..." } }
        }
      }
    }
  }
}
```

But your rules are written as if `cards`, `card`, etc. are at the root:

* `cards[*].holder.name` ❌ (root does not have `cards`)
* `card.number` ❌ (root does not have `card`)
* `card.details.name` ❌ (root does not have `card`)
* `cards[*].cvv` ❌ (root does not have `cards`)

Meanwhile, these work:

* `password` ✅ because you coded “no dots/brackets” to mean **mask anywhere**.
* `token` ✅ same reason.

So it’s behaving exactly as your code is written.

---

## Fix 1 (quick): Put the full path in appsettings

Update your rules to include the wrapper object:

```json
"Rules": [
  { "Path": "WSSOGEIBMBGETADDRESSResponse.cards[*].holder.name", "Replacement": "***" },

  { "Path": "WSSOGEIBMBGETADDRESSResponse.ESGBGLOBALBBType.gESGBGLOBALBBDetailType.card.number", "Replacement": "****MASKED****" },

  { "Path": "WSSOGEIBMBGETADDRESSResponse.ESGBGLOBALBBType.gESGBGLOBALBBDetailType.cards[*].cvv", "Replacement": "***" },

  { "Path": "WSSOGEIBMBGETADDRESSResponse.ESGBGLOBALBBType.gESGBGLOBALBBDetailType.mESGBGLOBALBBDetailType.card.details.name", "Replacement": "***" },

  { "Path": "password", "Replacement": "***" },
  { "Path": "token", "Replacement": "***" }
]
```

That will make your current implementation work.

---

## Fix 2 (best UX): Support “path anywhere” like `**.cards[*].cvv`

If you don’t want to hardcode the top wrapper (`WSSOGEIBMBGETADDRESSResponse`) because it changes per message, add a wildcard prefix meaning “match anywhere”.

### A simple approach:

If a rule path starts with `**.` then:

* search every object/array node as a potential starting point
* apply the remaining tokens from there

Example config:

```json
{ "Path": "**.cards[*].holder.name", "Replacement": "***" }
{ "Path": "**.cards[*].cvv", "Replacement": "***" }
{ "Path": "**.card.number", "Replacement": "****MASKED****" }
{ "Path": "**.card.details.name", "Replacement": "***" }
```

### Code change (minimal)

In `ApplyRule` add:

```csharp
if (rule.Path.StartsWith("**.", StringComparison.Ordinal))
{
    var trimmed = rule.Path[3..]; // remove "**."
    var tokens = MaskPath.Parse(trimmed);

    ApplyTokensFromAnywhere(root, tokens, rule.Replacement);
    return;
}
```

And implement:

```csharp
private static void ApplyTokensFromAnywhere(JToken root, List<PathToken> tokens, string replacement)
{
    // Try applying at the root
    ApplyTokens(root, tokens, 0, replacement);

    // Then try applying at every object/array node
    foreach (var node in root.DescendantsAndSelf())
    {
        if (node is JObject || node is JArray)
            ApplyTokens(node, tokens, 0, replacement);
    }
}

// helper (since DescendantsAndSelf isn't always available in some setups, you can implement it recursively)
private static IEnumerable<JToken> DescendantsAndSelf(this JToken node)
{
    yield return node;
    foreach (var child in node.Children())
        foreach (var d in child.DescendantsAndSelf())
            yield return d;
}
```

Now your original “short paths” work regardless of the outer wrapper.

---

## Small extra gotcha in your sample JSON

You have **two different `cards` arrays** in different places:

* `WSSOGEIBMBGETADDRESSResponse.cards` (has `holder.name`)
* `...gESGBGLOBALBBDetailType.cards` (has `cvv`)

So with “match anywhere” that’s fine, but with fully-qualified paths you must target the right one.

---

### Summary

Only `password` and `token` mask because they’re the only rules you treat as “match anywhere”. The other rules are rooted and don’t match your actual JSON structure. Either:

1. write full paths in config, or
2. add a wildcard prefix like `**.` to apply paths anywhere (recommended).

If you want, I can paste a cleaned-up `JsonMasker` with the `**.` feature integrated neatly into your current code.
