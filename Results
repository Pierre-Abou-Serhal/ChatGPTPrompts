Below is your code **with ‚Äúkeep last X characters‚Äù applied**, supporting:

* normal rooted paths
* `**.` ‚Äúanywhere‚Äù paths
* arrays `[*]`
* ‚Äúmask any property name anywhere‚Äù (the no-dot rule)
* works when value is **string or number** (card number can be `123456`)

I kept your structure and changed the minimum necessary.

---

## ‚úÖ What changes you need

### 1) Add these helpers inside `JsonMasker` (or as private methods)

```csharp
private static string MaskKeepLast(string input, int keepLast, char maskChar)
{
    if (string.IsNullOrEmpty(input)) return input;

    if (keepLast <= 0)
        return new string(maskChar, input.Length);

    if (input.Length <= keepLast)
        return input;

    return new string(maskChar, input.Length - keepLast) + input[^keepLast..];
}

private static string ApplyRuleToText(string? currentText, MaskRule rule)
{
    if (currentText is null) return rule.Replacement;

    if (rule.KeepLast is > 0)
        return MaskKeepLast(currentText, (int)rule.KeepLast.Value, rule.MaskChar);

    return rule.Replacement;
}
```

---

### 2) Modify `ApplyRule` so it passes the whole rule, not just `replacement`

Replace your `ApplyRule` with this:

```csharp
private static void ApplyRule(JToken root, MaskRule rule)
{
    if (string.IsNullOrWhiteSpace(rule.Path)) return;

    // If path has no dots/brackets: treat as "mask any property with this name anywhere"
    if (!rule.Path.Contains('.') && !rule.Path.Contains('[') && !rule.Path.StartsWith("**.", StringComparison.Ordinal))
    {
        MaskAllPropertiesNamed(root, rule.Path, rule);
        return;
    }

    if (rule.Path.StartsWith("**.", StringComparison.Ordinal))
    {
        var trimmed = rule.Path[3..]; // remove "**."
        var tokens = MaskPath.Parse(trimmed);
        ApplyTokensFromAnywhere(root, tokens, rule);
        return;
    }

    var normalTokens = MaskPath.Parse(rule.Path);
    ApplyTokens(root, normalTokens, 0, rule);
}
```

---

### 3) Update `ApplyTokens / HandleChild / ReplaceValue` signatures

Replace your `ApplyTokens`, `HandleChild`, `ReplaceValue`, `ApplyTokensFromAnywhere` with these:

```csharp
private static void ApplyTokens(JToken current, List<PathToken> tokens, int i, MaskRule rule)
{
    if (i >= tokens.Count)
    {
        ReplaceValue(current, rule);
        return;
    }

    var t = tokens[i];

    if (current is JObject obj)
    {
        if (!obj.TryGetValue(t.Name, out var child))
            return;

        HandleChild(child, tokens, i, rule, t);
        return;
    }

    if (current is JArray arr)
    {
        foreach (var item in arr)
            ApplyTokens(item, tokens, i, rule);
    }
}

private static void HandleChild(JToken child, List<PathToken> tokens, int i, MaskRule rule, PathToken t)
{
    if (t.AllItems)
    {
        if (child is JArray a)
            foreach (var item in a) ApplyTokens(item, tokens, i + 1, rule);
        return;
    }

    if (t.Index is not null)
    {
        if (child is JArray a && t.Index.Value >= 0 && t.Index.Value < a.Count)
            ApplyTokens(a[t.Index.Value]!, tokens, i + 1, rule);
        return;
    }

    ApplyTokens(child, tokens, i + 1, rule);
}

private static void ReplaceValue(JToken token, MaskRule rule)
{
    // If the token itself is a value (e.g. array items)
    if (token is JValue v)
    {
        var currentText = v.Value?.ToString();
        v.Value = ApplyRuleToText(currentText, rule);
        return;
    }

    // If the token is owned by a property, mask that property's value
    if (token.Parent is JProperty p)
    {
        var currentText = p.Value?.ToString();
        p.Value = ApplyRuleToText(currentText, rule);
    }
}

private static void ApplyTokensFromAnywhere(JToken root, List<PathToken> tokens, MaskRule rule)
{
    // Try applying at the root
    ApplyTokens(root, tokens, 0, rule);

    // Then try applying at every object/array node
    foreach (var node in root.DescendantsAndSelfJson())
    {
        if (node is JObject || node is JArray)
            ApplyTokens(node, tokens, 0, rule);
    }
}
```

---

### 4) Update ‚Äúmask any property name anywhere‚Äù to use the rule

Replace your `MaskAllPropertiesNamed` with this:

```csharp
private static void MaskAllPropertiesNamed(JToken root, string propName, MaskRule rule)
{
    switch (root)
    {
        case JObject obj:
        {
            foreach (var property in obj.Properties().ToList())
            {
                if (string.Equals(property.Name, propName, StringComparison.OrdinalIgnoreCase))
                {
                    var currentText = property.Value?.ToString();
                    property.Value = ApplyRuleToText(currentText, rule);
                }
                else
                {
                    MaskAllPropertiesNamed(property.Value, propName, rule);
                }
            }
            break;
        }

        case JArray arr:
        {
            foreach (var item in arr)
                MaskAllPropertiesNamed(item, propName, rule);
            break;
        }
    }
}
```

---

## ‚úÖ XML support (same KeepLast feature)

Right now your XML masker always does `el.Value = rule.Replacement`.
Update the ‚Äúset value‚Äù parts to use the same keep-last logic.

Add helpers inside `XmlMasker`:

```csharp
private static string MaskKeepLast(string input, int keepLast, char maskChar)
{
    if (string.IsNullOrEmpty(input)) return input;

    if (keepLast <= 0)
        return new string(maskChar, input.Length);

    if (input.Length <= keepLast)
        return input;

    return new string(maskChar, input.Length - keepLast) + input[^keepLast..];
}

private static string ApplyRuleToText(string? currentText, MaskRule rule)
{
    if (currentText is null) return rule.Replacement;

    if (rule.KeepLast is > 0)
        return MaskKeepLast(currentText, (int)rule.KeepLast.Value, rule.MaskChar);

    return rule.Replacement;
}
```

Then change two spots:

### A) In the ‚Äúmask any element named X anywhere‚Äù block:

```csharp
el.Value = ApplyRuleToText(el.Value, rule);
```

### B) In `ApplyTokens`, when you reach the final token:

Replace:

```csharp
current.Value = replacement;
```

with:

```csharp
current.Value = ApplyRuleToText(current.Value, rule);
```

And update signatures so `ApplyTokens(..., MaskRule rule)` instead of `replacement`.

---

## üî• Important note about your appsettings rules

You currently have:

```json
{ "Path": "token", "Replacement": "***", "KeepLast": 100 }
```

If the token length is **less than 100**, my logic returns it unchanged (since ‚Äúkeep last 100‚Äù = keep all).
That‚Äôs usually what you want, but if you want ‚Äúmask anyway even if shorter‚Äù, tell me and I‚Äôll adjust.

---

## Example result

For:

* `"number": 1234567890124128`
* rule `{ KeepLast: 4, MaskChar: '*' }`

Logged value becomes:

`************4128`

---

If you want, I can paste the **full updated JsonMasker + XmlMasker classes as complete blocks** (so you can copy/paste without manually editing).
