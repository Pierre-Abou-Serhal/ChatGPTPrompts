Perfect — job templates are a great choice for your setup.

Below I’ll give you:

1. **Build job template** (`build-dotnet-webapi-job.yml`)
2. **Deploy IIS job template** (`deploy-iis-job.yml`)
3. **How to use them** in your **DataExport** pipeline

---

# 1) Build Job Template

Create this file in your templates repo:

**`Azure Templates / Azure Templates / pipelines/build-dotnet-webapi-job.yml`**

```yml
parameters:
- name: jobName
  type: string
  default: 'BuildJob'

- name: jobDisplayName
  type: string
  default: 'Build (.NET)'

- name: buildPool
  type: string

- name: buildAgentName
  type: string

- name: buildConfiguration
  type: string
  default: 'Release'

- name: restoreProjects
  type: string
  default: '**/*.csproj'

- name: publishProject
  type: string

- name: nugetConfigPath
  type: string
  default: 'nuget.config'

- name: zipName
  type: string
  default: 'WebApp.zip'

jobs:
- job: ${{ parameters.jobName }}
  displayName: ${{ parameters.jobDisplayName }}

  pool:
    name: ${{ parameters.buildPool }}
    demands:
    - Agent.Name -equals ${{ parameters.buildAgentName }}

  steps:
  - checkout: self
    clean: true

  # Restore using nuget.config (important for private feeds)
  - task: DotNetCoreCLI@2
    displayName: 'Restore'
    inputs:
      command: 'restore'
      projects: ${{ parameters.restoreProjects }}
      feedsToUse: 'config'
      nugetConfigPath: ${{ parameters.nugetConfigPath }}

  - task: DotNetCoreCLI@2
    displayName: 'Build'
    inputs:
      command: 'build'
      projects: ${{ parameters.restoreProjects }}
      arguments: '--configuration ${{ parameters.buildConfiguration }} --no-restore'

  # Publish only the API project (avoids nested folder issues)
  - task: DotNetCoreCLI@2
    displayName: 'Publish'
    inputs:
      command: 'publish'
      projects: ${{ parameters.publishProject }}
      arguments: '--configuration ${{ parameters.buildConfiguration }} --output $(Build.ArtifactStagingDirectory)\publish --no-restore'
      zipAfterPublish: false

  - task: ArchiveFiles@2
    displayName: 'Zip publish output'
    inputs:
      rootFolderOrFile: '$(Build.ArtifactStagingDirectory)\publish'
      includeRootFolder: false
      archiveType: 'zip'
      archiveFile: '$(Build.ArtifactStagingDirectory)\${{ parameters.zipName }}'
      replaceExistingArchive: true

  # On-prem Azure DevOps Server: use Build Artifacts, not Pipeline Artifacts
  - task: PublishBuildArtifacts@1
    displayName: 'Publish Build Artifact'
    inputs:
      PathtoPublish: '$(Build.ArtifactStagingDirectory)\${{ parameters.zipName }}'
      ArtifactName: 'drop'
      publishLocation: 'Container'
```

---

# 2) Deploy IIS Job Template

Create this file in your templates repo:

**`Azure Templates / Azure Templates / pipelines/deploy-iis-job.yml`**

```yml
parameters:
- name: deploymentName
  type: string
  default: 'DeployJob'

- name: deploymentDisplayName
  type: string
  default: 'Deploy IIS'

- name: environmentName
  type: string

- name: deployPool
  type: string

- name: deployAgentName
  type: string

- name: variableGroup
  type: string

- name: zipName
  type: string

- name: siteName
  type: string

- name: appPoolName
  type: string

- name: iisTargetPath
  type: string

- name: appSettingsFilePattern
  type: string
  default: '**/appsettings.json'

jobs:
- deployment: ${{ parameters.deploymentName }}
  displayName: ${{ parameters.deploymentDisplayName }}

  environment: ${{ parameters.environmentName }}

  pool:
    name: ${{ parameters.deployPool }}
    demands:
    - Agent.Name -equals ${{ parameters.deployAgentName }}

  variables:
  - group: ${{ parameters.variableGroup }}

  strategy:
    runOnce:
      deploy:
        steps:
        - task: DownloadBuildArtifacts@0
          displayName: 'Download Build Artifact'
          inputs:
            buildType: 'current'
            downloadType: 'single'
            artifactName: 'drop'
            downloadPath: '$(Pipeline.Workspace)'

        - task: ExtractFiles@1
          displayName: 'Extract artifact'
          inputs:
            archiveFilePatterns: '$(Pipeline.Workspace)\drop\${{ parameters.zipName }}'
            destinationFolder: '$(Pipeline.Workspace)\extracted'
            cleanDestinationFolder: true

        - task: FileTransform@1
          displayName: 'JSON substitution (appsettings.json)'
          inputs:
            folderPath: '$(Pipeline.Workspace)\extracted'
            fileType: 'json'
            targetFiles: ${{ parameters.appSettingsFilePattern }}

        # Stop website + app pool safely (idempotent)
        - powershell: |
            Import-Module WebAdministration

            $siteName = "${{ parameters.siteName }}"
            $appPool  = "${{ parameters.appPoolName }}"

            $site = Get-Website -Name $siteName
            Write-Host "Website current state: $($site.State)"
            if ($site.State -ne "Stopped") {
              Write-Host "Stopping website: $siteName"
              Stop-Website -Name $siteName
            } else {
              Write-Host "Website already stopped."
            }

            $poolState = (Get-WebAppPoolState -Name $appPool).Value
            Write-Host "AppPool current state: $poolState"
            if ($poolState -ne "Stopped") {
              Write-Host "Stopping app pool: $appPool"
              Stop-WebAppPool -Name $appPool
            } else {
              Write-Host "AppPool already stopped."
            }

            $maxTries = 30
            for ($i = 1; $i -le $maxTries; $i++) {
              $siteState = (Get-Website -Name $siteName).State
              $poolState = (Get-WebAppPoolState -Name $appPool).Value

              Write-Host "Website state: $siteState | AppPool state: $poolState"

              if ($siteState -eq "Stopped" -and $poolState -eq "Stopped") {
                Write-Host "Website and App Pool are stopped."
                break
              }

              Start-Sleep -Seconds 2
            }

            $finalSiteState = (Get-Website -Name $siteName).State
            $finalPoolState = (Get-WebAppPoolState -Name $appPool).Value

            if ($finalSiteState -ne "Stopped" -or $finalPoolState -ne "Stopped") {
              throw "Failed to stop Website/AppPool. Final states => Website: $finalSiteState | AppPool: $finalPoolState"
            }

            Start-Sleep -Seconds 2
          displayName: 'Stop Website + App Pool'

        - task: CopyFiles@2
          displayName: 'Copy files'
          inputs:
            SourceFolder: '$(Pipeline.Workspace)\extracted'
            Contents: '**'
            TargetFolder: '${{ parameters.iisTargetPath }}'
            OverWrite: true

        # Start website + app pool safely (idempotent)
        - powershell: |
            Import-Module WebAdministration

            $siteName = "${{ parameters.siteName }}"
            $appPool  = "${{ parameters.appPoolName }}"

            $poolState = (Get-WebAppPoolState -Name $appPool).Value
            if ($poolState -ne "Started") {
              Write-Host "Starting app pool: $appPool"
              Start-WebAppPool -Name $appPool
            } else {
              Write-Host "AppPool already started."
            }

            $siteState = (Get-Website -Name $siteName).State
            if ($siteState -ne "Started") {
              Write-Host "Starting website: $siteName"
              Start-Website -Name $siteName
            } else {
              Write-Host "Website already started."
            }

            $siteState = (Get-Website -Name $siteName).State
            $poolState = (Get-WebAppPoolState -Name $appPool).Value
            Write-Host "Website state: $siteState | AppPool state: $poolState"
          displayName: 'Start Website + App Pool'
```

---

# 3) Use them in your DataExport project pipeline

In your **DataExport repo** (`azure-pipelines.yml`), use this:

```yml
resources:
  repositories:
  - repository: templates
    type: git
    name: 'Azure Templates/Azure Templates'
    ref: refs/heads/master

trigger:
  branches:
    include:
    - sit
    - uat
    - master

variables:
  buildConfiguration: 'Release'

stages:
# =========================
# BUILD
# =========================
- stage: Build
  displayName: 'Build & Publish Artifact'
  jobs:
  - template: pipelines/build-dotnet-webapi-job.yml@templates
    parameters:
      jobName: 'BuildJob'
      jobDisplayName: 'Build DataExport'
      buildPool: 'Build Pool'
      buildAgentName: 'UAT-ALTERNA-DK1'
      buildConfiguration: 'Release'
      restoreProjects: '**/*.csproj'
      publishProject: 'Alterna-DataExport/Alterna-DataExport/Alterna-DataExport.csproj'
      nugetConfigPath: 'nuget.config'
      zipName: 'Alterna-DataExport.zip'

# =========================
# DEPLOY SIT
# =========================
- stage: Deploy_SIT
  displayName: 'Deploy to SIT'
  dependsOn: Build
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/sit'))
  jobs:
  - template: pipelines/deploy-iis-job.yml@templates
    parameters:
      deploymentName: 'DeploySIT'
      deploymentDisplayName: 'Deploy SIT (IIS)'
      environmentName: 'SIT'
      deployPool: 'Build Pool'
      deployAgentName: 'SIT-ALTERNA-BN1'
      variableGroup: 'SIT_VARIABLE_GROUP'
      zipName: 'Alterna-DataExport.zip'
      siteName: 'AlternaDataExportServiceAzureDevOps'
      appPoolName: 'AlternaDataExportServiceAzureDevOps'
      iisTargetPath: 'C:\inetpub\wwwroot\AlternaDataExportService-AzureDevOps-BN1'

# =========================
# DEPLOY UAT
# =========================
- stage: Deploy_UAT
  displayName: 'Deploy to UAT'
  dependsOn: Build
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/uat'))
  jobs:
  - template: pipelines/deploy-iis-job.yml@templates
    parameters:
      deploymentName: 'DeployUAT'
      deploymentDisplayName: 'Deploy UAT (IIS)'
      environmentName: 'UAT'         # approvals come from Environment checks
      deployPool: 'Build Pool'       # or IIS-UAT if you create a dedicated pool
      deployAgentName: 'UAT-ALTERNA-DK1'
      variableGroup: 'UAT_VARIABLE_GROUP'
      zipName: 'Alterna-DataExport.zip'
      siteName: 'AlternaDataExportServiceAzureDevOps'
      appPoolName: 'AlternaDataExportServiceAzureDevOps'
      iisTargetPath: 'C:\inetpub\wwwroot\AlternaDataExportService-AzureDevOps-DK1'

# =========================
# DEPLOY PROD
# =========================
- stage: Deploy_PROD
  displayName: 'Deploy to PROD'
  dependsOn: Build
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
  jobs:
  - template: pipelines/deploy-iis-job.yml@templates
    parameters:
      deploymentName: 'DeployPROD'
      deploymentDisplayName: 'Deploy PROD (IIS)'
      environmentName: 'PROD'        # approvals come from Environment checks
      deployPool: 'Build Pool'       # or IIS-PROD (recommended later)
      deployAgentName: 'PROD-ALTERNA-XX1'   # <-- replace with actual PROD agent
      variableGroup: 'PRD_VARIABLE_GROUP'
      zipName: 'Alterna-DataExport.zip'
      siteName: 'AlternaDataExportServiceAzureDevOps'
      appPoolName: 'AlternaDataExportServiceAzureDevOps'
      iisTargetPath: 'C:\inetpub\wwwroot\AlternaDataExportService-AzureDevOps-PROD'
```

---

## Notes for your DataExport pipeline

### 1) `nuget.config`

Keep your `nuget.config` in the repo root and make sure the private feed is there.

### 2) Variable group names for JSON substitution

Use **dot notation**, not `:`:

* `AppSettings.DataExportConnectionString`
* `AppSettings.FTPConfigurations.FtpAddress`
* `Serilog.WriteTo[0].Args.path`

### 3) Environment approvals

Since the deploy template uses `environment: 'UAT'` and `environment: 'PROD'`, your **Environment checks/approvals** will trigger automatically.

### 4) On-prem compatibility

These templates use:

* `PublishBuildArtifacts@1`
* `DownloadBuildArtifacts@0`

✅ Good for Azure DevOps Server on-prem.

---

## First-run checklist

When you use the templates repo for the first time:

* Azure DevOps may ask to **authorize** the templates repo resource → approve it.

---

If you want, next I can give you:

* a **second version** of the deploy template with optional `app_offline.htm` support (toggle true/false), or
* a **single combined template** that creates Build + Deploy jobs for all environments from one file.
